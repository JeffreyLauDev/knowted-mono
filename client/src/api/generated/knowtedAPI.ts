/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * Knowted API
 * The Knowted API documentation
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AcceptInvitationDto,
  AcceptInvitationResponseDto,
  AddToLiveMeetingDto,
  AddToLiveMeetingResponseDto,
  AiConversationHistoriesControllerCreateParams,
  AiConversationHistoriesControllerFindAllParams,
  AiConversationHistoriesControllerFindBySessionIdParams,
  AiConversationHistoriesResponseDto,
  AiConversationSessionResponseDto,
  AiConversationSessionsControllerCreateParams,
  AiConversationSessionsControllerFindAllParams,
  AiConversationSessionsControllerFindOneParams,
  AiConversationSessionsControllerRemove200,
  AiConversationSessionsControllerRemoveParams,
  AiConversationSessionsControllerUpdateParams,
  ApiKeyResponseDto,
  AuthControllerLogin200,
  AuthControllerLogin401,
  AvailablePlansResponseDto,
  BillingPortalSessionResponseDto,
  BulkInviteUsersDto,
  BulkSetTeamPermissionsDto,
  CalendarControllerDisconnectCalendarParams,
  CalendarControllerGenerateOAuthUrlParams,
  CalendarControllerGetCalendarSyncStatusParams,
  CalendarControllerGetEventSyncStatusParams,
  CalendarControllerHandleOAuthCallbackParams,
  CalendarControllerListAvailableCalendarsParams,
  CalendarControllerListMyCalendarsParams,
  CalendarControllerRefreshCalendarsByOrganizationParams,
  CalendarControllerSyncSpecificCalendarParams,
  CalendarControllerUnsyncSpecificCalendarParams,
  CalendarSyncStatusDto,
  CancelInvitationDto,
  CancelInvitationResponseDto,
  CheckoutSessionResponseDto,
  CompleteMeetingDto,
  CreateAiConversationHistoriesDto,
  CreateAiConversationSessionsDto,
  CreateApiKeyDto,
  CreateCheckoutSessionDto,
  CreateMeetingShareDto,
  CreateMeetingTypeDto,
  CreateOrganizationsDto,
  CreateReportTypesDto,
  CreateTeamsDto,
  CreateWebhookDto,
  CurrentPlanDto,
  DisconnectCalendarResponseDto,
  EventSyncStatusResponseDto,
  GenerateAnalysisTopicsDto,
  GenerateMeetingTypeDto,
  HealthControllerGetHealth200,
  HealthControllerPostHealth200,
  InvitationResponseDto,
  InviteUserDto,
  InvoiceResponseDto,
  ListMyCalendarsResponseDto,
  LoginDto,
  MeetingBaasWebhookDto,
  MeetingResponseDto,
  MeetingShareResponseDto,
  MeetingTypeResponse,
  MeetingTypesControllerCreateParams,
  MeetingTypesControllerFindAllParams,
  MeetingTypesControllerGenerateAnalysisTopics201,
  MeetingTypesControllerGenerateAnalysisTopicsParams,
  MeetingTypesControllerGenerateMeetingType201,
  MeetingTypesControllerRemoveParams,
  MeetingTypesControllerUpdateParams,
  Meetings,
  MeetingsControllerAddToLiveMeetingParams,
  MeetingsControllerCompleteMeetingParams,
  MeetingsControllerCreateShareLinkParams,
  MeetingsControllerDeleteParams,
  MeetingsControllerDeleteShareLinkParams,
  MeetingsControllerFindAllParams,
  MeetingsControllerFindOneParams,
  MeetingsControllerGetMeetingStreamingUrlParams,
  MeetingsControllerGetMeetingVideoUrl200,
  MeetingsControllerGetMeetingVideoUrlParams,
  MeetingsControllerGetNextBotEvent200,
  MeetingsControllerGetNextBotEventParams,
  MeetingsControllerGetShareLinkParams,
  MeetingsControllerGetSharedMeetingParams,
  MeetingsControllerGetUpcomingScheduledEvents200,
  MeetingsControllerGetUpcomingScheduledEventsParams,
  MeetingsControllerScheduleMeetingParams,
  MeetingsControllerStreamMeetingVideoParams,
  MeetingsControllerSubmitCompleteMeetingData200,
  MeetingsControllerSubmitCompleteMeetingDataParams,
  MeetingsControllerUpdateParams,
  MeetingsControllerUpdateShareLinkParams,
  MeetingsControllerValidateShareToken200,
  MeetingsControllerValidateShareTokenParams,
  MonthlyMinutesResetDto,
  MonthlyMinutesResetHistoryDto,
  OnboardingDto,
  OrganizationMemberResponseDto,
  OrganizationResponseDto,
  OrganizationsControllerCancelInvitationParams,
  PaginatedMeetingsResponseDto,
  PaymentControllerCreateBillingPortalSessionParams,
  PaymentControllerCreateFreeTrialCheckoutSessionParams,
  PaymentControllerGetCompatiblePlans200,
  PaymentControllerGetCompatiblePlansParams,
  PaymentControllerGetCurrentPlanParams,
  PaymentControllerGetInvoicesParams,
  PaymentControllerGetPaymentHistoryParams,
  PaymentControllerGetSeatLimitForPlan200,
  PaymentControllerUpdateSubscriptionSeats200,
  PaymentControllerUpdateSubscriptionSeatsParams,
  PaymentControllerValidateSeatAdditionParams,
  PaymentHistoryResponseDto,
  PendingInvitationResponseDto,
  Permissions,
  PermissionsControllerBulkSetTeamPermissionsParams,
  PermissionsControllerGetOrganizationPermissionsParams,
  PermissionsControllerGetTeamPermissionsParams,
  PricingConfigurationDto,
  PricingPlanDto,
  ProfilesControllerGetProfile200,
  ProfilesControllerUpdateProfile200,
  PublicMeetingsControllerGetSharedMeetingStreamingUrlParams,
  PublicMeetingsControllerStreamMeetingVideoParams,
  ReportTypeResponseDto,
  ReportTypesControllerCreateParams,
  ReportTypesControllerFindAllParams,
  ReportTypesControllerFindOneParams,
  ReportTypesControllerRemoveParams,
  ReportTypesControllerUpdateParams,
  ScheduleMeetingDto,
  ScheduleMeetingResponseDto,
  SeatUsageDto,
  SeatValidationDto,
  SubscriptionDetailsResponseDto,
  SubscriptionStatusResponseDto,
  TeamResponseDto,
  TeamsControllerCreateParams,
  TeamsControllerFindAllParams,
  TeamsControllerFindOneParams,
  TeamsControllerRemoveParams,
  TeamsControllerUpdateParams,
  UpdateAiConversationHistoriesDto,
  UpdateAiConversationSessionsDto,
  UpdateApiKeyDto,
  UpdateMeetingDto,
  UpdateMeetingShareDto,
  UpdateMeetingTypeDto,
  UpdateOrganizationsDto,
  UpdateProfileDto,
  UpdateReportTypesDto,
  UpdateSubscriptionSeatsDto,
  UpdateTeamsDto,
  UpdateUserTeamDto,
  UpdateWebhookDto,
  UpgradeCheckDto,
  UsageEventsControllerGetCurrentUsageParams,
  UsageEventsControllerGetEventsParams,
  UsageEventsControllerGetMonthlyMinutesResetHistoryParams,
  UsageEventsControllerGetUsageSummaryParams,
  UsageEventsControllerResetMonthlyMinutesUsageParams,
  VideoStreamResponseDto,
  WebhookResponseDto,
} from "./models";

import { customInstance } from "../mutator/custom-instance";

/**
 * Create a new user account
 * @summary User signup
 */
export const authControllerSignUp = (
  loginDto: LoginDto,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/auth/signup`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: loginDto,
    signal,
  });
};

export const getAuthControllerSignUpMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerSignUp>>,
    TError,
    { data: LoginDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerSignUp>>,
  TError,
  { data: LoginDto },
  TContext
> => {
  const mutationKey = ["authControllerSignUp"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerSignUp>>,
    { data: LoginDto }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerSignUp(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerSignUpMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerSignUp>>
>;
export type AuthControllerSignUpMutationBody = LoginDto;
export type AuthControllerSignUpMutationError = null;

/**
 * @summary User signup
 */
export const useAuthControllerSignUp = <TError = null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerSignUp>>,
      TError,
      { data: LoginDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerSignUp>>,
  TError,
  { data: LoginDto },
  TContext
> => {
  const mutationOptions = getAuthControllerSignUpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Authenticate a user and return a JWT token
 * @summary User login
 */
export const authControllerLogin = (
  loginDto: LoginDto,
  signal?: AbortSignal,
) => {
  return customInstance<AuthControllerLogin200>({
    url: `/api/v1/auth/login`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: loginDto,
    signal,
  });
};

export const getAuthControllerLoginMutationOptions = <
  TError = AuthControllerLogin401,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLogin>>,
    TError,
    { data: LoginDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerLogin>>,
  TError,
  { data: LoginDto },
  TContext
> => {
  const mutationKey = ["authControllerLogin"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLogin>>,
    { data: LoginDto }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerLogin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLogin>>
>;
export type AuthControllerLoginMutationBody = LoginDto;
export type AuthControllerLoginMutationError = AuthControllerLogin401;

/**
 * @summary User login
 */
export const useAuthControllerLogin = <
  TError = AuthControllerLogin401,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerLogin>>,
      TError,
      { data: LoginDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerLogin>>,
  TError,
  { data: LoginDto },
  TContext
> => {
  const mutationOptions = getAuthControllerLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Sign out the current user
 * @summary User signout
 */
export const authControllerSignOut = (signal?: AbortSignal) => {
  return customInstance<null>({
    url: `/api/v1/auth/signout`,
    method: "POST",
    signal,
  });
};

export const getAuthControllerSignOutMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerSignOut>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerSignOut>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["authControllerSignOut"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerSignOut>>,
    void
  > = () => {
    return authControllerSignOut();
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerSignOutMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerSignOut>>
>;

export type AuthControllerSignOutMutationError = unknown;

/**
 * @summary User signout
 */
export const useAuthControllerSignOut = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerSignOut>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerSignOut>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getAuthControllerSignOutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve the current user's profile information
 * @summary Get current user profile
 */
export const profilesControllerGetProfile = (signal?: AbortSignal) => {
  return customInstance<ProfilesControllerGetProfile200>({
    url: `/api/v1/profiles/me`,
    method: "GET",
    signal,
  });
};

export const getProfilesControllerGetProfileQueryKey = () => {
  return [`/api/v1/profiles/me`] as const;
};

export const getProfilesControllerGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof profilesControllerGetProfile>>,
  TError = null | null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof profilesControllerGetProfile>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getProfilesControllerGetProfileQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof profilesControllerGetProfile>>
  > = ({ signal }) => profilesControllerGetProfile(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof profilesControllerGetProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ProfilesControllerGetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof profilesControllerGetProfile>>
>;
export type ProfilesControllerGetProfileQueryError = null | null;

export function useProfilesControllerGetProfile<
  TData = Awaited<ReturnType<typeof profilesControllerGetProfile>>,
  TError = null | null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof profilesControllerGetProfile>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof profilesControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof profilesControllerGetProfile>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useProfilesControllerGetProfile<
  TData = Awaited<ReturnType<typeof profilesControllerGetProfile>>,
  TError = null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof profilesControllerGetProfile>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof profilesControllerGetProfile>>,
          TError,
          Awaited<ReturnType<typeof profilesControllerGetProfile>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useProfilesControllerGetProfile<
  TData = Awaited<ReturnType<typeof profilesControllerGetProfile>>,
  TError = null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof profilesControllerGetProfile>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get current user profile
 */

export function useProfilesControllerGetProfile<
  TData = Awaited<ReturnType<typeof profilesControllerGetProfile>>,
  TError = null | null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof profilesControllerGetProfile>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getProfilesControllerGetProfileQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update the current user's first name and last name
 * @summary Update user profile
 */
export const profilesControllerUpdateProfile = (
  updateProfileDto: UpdateProfileDto,
) => {
  return customInstance<ProfilesControllerUpdateProfile200>({
    url: `/api/v1/profiles/me`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateProfileDto,
  });
};

export const getProfilesControllerUpdateProfileMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof profilesControllerUpdateProfile>>,
    TError,
    { data: UpdateProfileDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof profilesControllerUpdateProfile>>,
  TError,
  { data: UpdateProfileDto },
  TContext
> => {
  const mutationKey = ["profilesControllerUpdateProfile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof profilesControllerUpdateProfile>>,
    { data: UpdateProfileDto }
  > = (props) => {
    const { data } = props ?? {};

    return profilesControllerUpdateProfile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ProfilesControllerUpdateProfileMutationResult = NonNullable<
  Awaited<ReturnType<typeof profilesControllerUpdateProfile>>
>;
export type ProfilesControllerUpdateProfileMutationBody = UpdateProfileDto;
export type ProfilesControllerUpdateProfileMutationError = null | null;

/**
 * @summary Update user profile
 */
export const useProfilesControllerUpdateProfile = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof profilesControllerUpdateProfile>>,
      TError,
      { data: UpdateProfileDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof profilesControllerUpdateProfile>>,
  TError,
  { data: UpdateProfileDto },
  TContext
> => {
  const mutationOptions =
    getProfilesControllerUpdateProfileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Permanently delete the current user's account and all associated data
 * @summary Delete user account
 */
export const profilesControllerDeleteAccount = () => {
  return customInstance<null>({ url: `/api/v1/profiles/me`, method: "DELETE" });
};

export const getProfilesControllerDeleteAccountMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof profilesControllerDeleteAccount>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof profilesControllerDeleteAccount>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["profilesControllerDeleteAccount"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof profilesControllerDeleteAccount>>,
    void
  > = () => {
    return profilesControllerDeleteAccount();
  };

  return { mutationFn, ...mutationOptions };
};

export type ProfilesControllerDeleteAccountMutationResult = NonNullable<
  Awaited<ReturnType<typeof profilesControllerDeleteAccount>>
>;

export type ProfilesControllerDeleteAccountMutationError = null;

/**
 * @summary Delete user account
 */
export const useProfilesControllerDeleteAccount = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof profilesControllerDeleteAccount>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof profilesControllerDeleteAccount>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getProfilesControllerDeleteAccountMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Export all user data in JSON format for GDPR compliance
 * @summary Export user data
 */
export const profilesControllerExportData = (signal?: AbortSignal) => {
  return customInstance<null>({
    url: `/api/v1/profiles/export`,
    method: "GET",
    signal,
  });
};

export const getProfilesControllerExportDataQueryKey = () => {
  return [`/api/v1/profiles/export`] as const;
};

export const getProfilesControllerExportDataQueryOptions = <
  TData = Awaited<ReturnType<typeof profilesControllerExportData>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof profilesControllerExportData>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getProfilesControllerExportDataQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof profilesControllerExportData>>
  > = ({ signal }) => profilesControllerExportData(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof profilesControllerExportData>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ProfilesControllerExportDataQueryResult = NonNullable<
  Awaited<ReturnType<typeof profilesControllerExportData>>
>;
export type ProfilesControllerExportDataQueryError = null;

export function useProfilesControllerExportData<
  TData = Awaited<ReturnType<typeof profilesControllerExportData>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof profilesControllerExportData>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof profilesControllerExportData>>,
          TError,
          Awaited<ReturnType<typeof profilesControllerExportData>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useProfilesControllerExportData<
  TData = Awaited<ReturnType<typeof profilesControllerExportData>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof profilesControllerExportData>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof profilesControllerExportData>>,
          TError,
          Awaited<ReturnType<typeof profilesControllerExportData>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useProfilesControllerExportData<
  TData = Awaited<ReturnType<typeof profilesControllerExportData>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof profilesControllerExportData>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Export user data
 */

export function useProfilesControllerExportData<
  TData = Awaited<ReturnType<typeof profilesControllerExportData>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof profilesControllerExportData>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getProfilesControllerExportDataQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new organization
 */
export const organizationsControllerCreate = (
  createOrganizationsDto: CreateOrganizationsDto,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createOrganizationsDto,
    signal,
  });
};

export const getOrganizationsControllerCreateMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerCreate>>,
    TError,
    { data: CreateOrganizationsDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerCreate>>,
  TError,
  { data: CreateOrganizationsDto },
  TContext
> => {
  const mutationKey = ["organizationsControllerCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerCreate>>,
    { data: CreateOrganizationsDto }
  > = (props) => {
    const { data } = props ?? {};

    return organizationsControllerCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerCreate>>
>;
export type OrganizationsControllerCreateMutationBody = CreateOrganizationsDto;
export type OrganizationsControllerCreateMutationError = null | null;

/**
 * @summary Create a new organization
 */
export const useOrganizationsControllerCreate = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerCreate>>,
      TError,
      { data: CreateOrganizationsDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerCreate>>,
  TError,
  { data: CreateOrganizationsDto },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all organizations the user has access to
 */
export const organizationsControllerFindAll = (signal?: AbortSignal) => {
  return customInstance<null>({
    url: `/api/v1/organizations`,
    method: "GET",
    signal,
  });
};

export const getOrganizationsControllerFindAllQueryKey = () => {
  return [`/api/v1/organizations`] as const;
};

export const getOrganizationsControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsControllerFindAll>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof organizationsControllerFindAll>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOrganizationsControllerFindAllQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof organizationsControllerFindAll>>
  > = ({ signal }) => organizationsControllerFindAll(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type OrganizationsControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerFindAll>>
>;
export type OrganizationsControllerFindAllQueryError = null;

export function useOrganizationsControllerFindAll<
  TData = Awaited<ReturnType<typeof organizationsControllerFindAll>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof organizationsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof organizationsControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useOrganizationsControllerFindAll<
  TData = Awaited<ReturnType<typeof organizationsControllerFindAll>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof organizationsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof organizationsControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useOrganizationsControllerFindAll<
  TData = Awaited<ReturnType<typeof organizationsControllerFindAll>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all organizations the user has access to
 */

export function useOrganizationsControllerFindAll<
  TData = Awaited<ReturnType<typeof organizationsControllerFindAll>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getOrganizationsControllerFindAllQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all pending invitations for the authenticated user
 */
export const organizationsControllerGetMyInvitations = (
  signal?: AbortSignal,
) => {
  return customInstance<InvitationResponseDto[]>({
    url: `/api/v1/organizations/my-invitations`,
    method: "GET",
    signal,
  });
};

export const getOrganizationsControllerGetMyInvitationsQueryKey = () => {
  return [`/api/v1/organizations/my-invitations`] as const;
};

export const getOrganizationsControllerGetMyInvitationsQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
  TError = null,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getOrganizationsControllerGetMyInvitationsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>
  > = ({ signal }) => organizationsControllerGetMyInvitations(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type OrganizationsControllerGetMyInvitationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>
>;
export type OrganizationsControllerGetMyInvitationsQueryError = null;

export function useOrganizationsControllerGetMyInvitations<
  TData = Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
  TError = null,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
          TError,
          Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useOrganizationsControllerGetMyInvitations<
  TData = Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
          TError,
          Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useOrganizationsControllerGetMyInvitations<
  TData = Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all pending invitations for the authenticated user
 */

export function useOrganizationsControllerGetMyInvitations<
  TData = Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
  TError = null,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerGetMyInvitations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getOrganizationsControllerGetMyInvitationsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Complete organization onboarding
 */
export const organizationsControllerCompleteOnboarding = (
  onboardingDto: OnboardingDto,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations/onboarding`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: onboardingDto,
    signal,
  });
};

export const getOrganizationsControllerCompleteOnboardingMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerCompleteOnboarding>>,
    TError,
    { data: OnboardingDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerCompleteOnboarding>>,
  TError,
  { data: OnboardingDto },
  TContext
> => {
  const mutationKey = ["organizationsControllerCompleteOnboarding"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerCompleteOnboarding>>,
    { data: OnboardingDto }
  > = (props) => {
    const { data } = props ?? {};

    return organizationsControllerCompleteOnboarding(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerCompleteOnboardingMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof organizationsControllerCompleteOnboarding>>
  >;
export type OrganizationsControllerCompleteOnboardingMutationBody =
  OnboardingDto;
export type OrganizationsControllerCompleteOnboardingMutationError =
  | null
  | null;

/**
 * @summary Complete organization onboarding
 */
export const useOrganizationsControllerCompleteOnboarding = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerCompleteOnboarding>>,
      TError,
      { data: OnboardingDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerCompleteOnboarding>>,
  TError,
  { data: OnboardingDto },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerCompleteOnboardingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get organization details by ID
 */
export const organizationsControllerFindOne = (
  id: string,
  signal?: AbortSignal,
) => {
  return customInstance<OrganizationResponseDto>({
    url: `/api/v1/organizations/${id}`,
    method: "GET",
    signal,
  });
};

export const getOrganizationsControllerFindOneQueryKey = (id?: string) => {
  return [`/api/v1/organizations/${id}`] as const;
};

export const getOrganizationsControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof organizationsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getOrganizationsControllerFindOneQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof organizationsControllerFindOne>>
  > = ({ signal }) => organizationsControllerFindOne(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type OrganizationsControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerFindOne>>
>;
export type OrganizationsControllerFindOneQueryError = null | null | null;

export function useOrganizationsControllerFindOne<
  TData = Awaited<ReturnType<typeof organizationsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof organizationsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof organizationsControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useOrganizationsControllerFindOne<
  TData = Awaited<ReturnType<typeof organizationsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof organizationsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof organizationsControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useOrganizationsControllerFindOne<
  TData = Awaited<ReturnType<typeof organizationsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get organization details by ID
 */

export function useOrganizationsControllerFindOne<
  TData = Awaited<ReturnType<typeof organizationsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof organizationsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getOrganizationsControllerFindOneQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update an organization
 */
export const organizationsControllerUpdate = (
  id: string,
  updateOrganizationsDto: UpdateOrganizationsDto,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateOrganizationsDto,
  });
};

export const getOrganizationsControllerUpdateMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerUpdate>>,
    TError,
    { id: string; data: UpdateOrganizationsDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerUpdate>>,
  TError,
  { id: string; data: UpdateOrganizationsDto },
  TContext
> => {
  const mutationKey = ["organizationsControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerUpdate>>,
    { id: string; data: UpdateOrganizationsDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return organizationsControllerUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerUpdate>>
>;
export type OrganizationsControllerUpdateMutationBody = UpdateOrganizationsDto;
export type OrganizationsControllerUpdateMutationError = null | null | null;

/**
 * @summary Update an organization
 */
export const useOrganizationsControllerUpdate = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerUpdate>>,
      TError,
      { id: string; data: UpdateOrganizationsDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerUpdate>>,
  TError,
  { id: string; data: UpdateOrganizationsDto },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete an organization
 */
export const organizationsControllerRemove = (id: string) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${id}`,
    method: "DELETE",
  });
};

export const getOrganizationsControllerRemoveMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerRemove>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["organizationsControllerRemove"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerRemove>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return organizationsControllerRemove(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerRemove>>
>;

export type OrganizationsControllerRemoveMutationError = null | null | null;

/**
 * @summary Delete an organization
 */
export const useOrganizationsControllerRemove = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerRemove>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Update organization onboarding data
 */
export const organizationsControllerUpdateOnboarding = (
  id: string,
  onboardingDto: OnboardingDto,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${id}/onboarding`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: onboardingDto,
  });
};

export const getOrganizationsControllerUpdateOnboardingMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerUpdateOnboarding>>,
    TError,
    { id: string; data: OnboardingDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerUpdateOnboarding>>,
  TError,
  { id: string; data: OnboardingDto },
  TContext
> => {
  const mutationKey = ["organizationsControllerUpdateOnboarding"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerUpdateOnboarding>>,
    { id: string; data: OnboardingDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return organizationsControllerUpdateOnboarding(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerUpdateOnboardingMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerUpdateOnboarding>>
>;
export type OrganizationsControllerUpdateOnboardingMutationBody = OnboardingDto;
export type OrganizationsControllerUpdateOnboardingMutationError =
  | null
  | null
  | null;

/**
 * @summary Update organization onboarding data
 */
export const useOrganizationsControllerUpdateOnboarding = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerUpdateOnboarding>>,
      TError,
      { id: string; data: OnboardingDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerUpdateOnboarding>>,
  TError,
  { id: string; data: OnboardingDto },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerUpdateOnboardingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Update organization API token
 */
export const organizationsControllerUpdateApiToken = (id: string) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${id}/api-token`,
    method: "PATCH",
  });
};

export const getOrganizationsControllerUpdateApiTokenMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerUpdateApiToken>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerUpdateApiToken>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["organizationsControllerUpdateApiToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerUpdateApiToken>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return organizationsControllerUpdateApiToken(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerUpdateApiTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerUpdateApiToken>>
>;

export type OrganizationsControllerUpdateApiTokenMutationError =
  | null
  | null
  | null;

/**
 * @summary Update organization API token
 */
export const useOrganizationsControllerUpdateApiToken = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerUpdateApiToken>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerUpdateApiToken>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerUpdateApiTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Cancel an organization invitation
 */
export const organizationsControllerCancelInvitation = (
  cancelInvitationDto: CancelInvitationDto,
  params: OrganizationsControllerCancelInvitationParams,
) => {
  return customInstance<CancelInvitationResponseDto>({
    url: `/api/v1/organizations/cancel-invitation`,
    method: "DELETE",
    headers: { "Content-Type": "application/json" },
    data: cancelInvitationDto,
    params,
  });
};

export const getOrganizationsControllerCancelInvitationMutationOptions = <
  TError = null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerCancelInvitation>>,
    TError,
    {
      data: CancelInvitationDto;
      params: OrganizationsControllerCancelInvitationParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerCancelInvitation>>,
  TError,
  {
    data: CancelInvitationDto;
    params: OrganizationsControllerCancelInvitationParams;
  },
  TContext
> => {
  const mutationKey = ["organizationsControllerCancelInvitation"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerCancelInvitation>>,
    {
      data: CancelInvitationDto;
      params: OrganizationsControllerCancelInvitationParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return organizationsControllerCancelInvitation(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerCancelInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerCancelInvitation>>
>;
export type OrganizationsControllerCancelInvitationMutationBody =
  CancelInvitationDto;
export type OrganizationsControllerCancelInvitationMutationError =
  | null
  | null
  | null
  | null;

/**
 * @summary Cancel an organization invitation
 */
export const useOrganizationsControllerCancelInvitation = <
  TError = null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerCancelInvitation>>,
      TError,
      {
        data: CancelInvitationDto;
        params: OrganizationsControllerCancelInvitationParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerCancelInvitation>>,
  TError,
  {
    data: CancelInvitationDto;
    params: OrganizationsControllerCancelInvitationParams;
  },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerCancelInvitationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Removes a user from the specified organization.
 * @summary Remove a user from an organization
 */
export const organizationsControllerRemoveUserFromOrganization = (
  id: string,
  userId: string,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${id}/users/${userId}`,
    method: "DELETE",
  });
};

export const getOrganizationsControllerRemoveUserFromOrganizationMutationOptions =
  <TError = null | null | null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof organizationsControllerRemoveUserFromOrganization>
      >,
      TError,
      { id: string; userId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof organizationsControllerRemoveUserFromOrganization>
    >,
    TError,
    { id: string; userId: string },
    TContext
  > => {
    const mutationKey = ["organizationsControllerRemoveUserFromOrganization"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof organizationsControllerRemoveUserFromOrganization>
      >,
      { id: string; userId: string }
    > = (props) => {
      const { id, userId } = props ?? {};

      return organizationsControllerRemoveUserFromOrganization(id, userId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type OrganizationsControllerRemoveUserFromOrganizationMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof organizationsControllerRemoveUserFromOrganization>
    >
  >;

export type OrganizationsControllerRemoveUserFromOrganizationMutationError =
  | null
  | null
  | null
  | null;

/**
 * @summary Remove a user from an organization
 */
export const useOrganizationsControllerRemoveUserFromOrganization = <
  TError = null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof organizationsControllerRemoveUserFromOrganization>
      >,
      TError,
      { id: string; userId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerRemoveUserFromOrganization>>,
  TError,
  { id: string; userId: string },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerRemoveUserFromOrganizationMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Updates a user's team within the organization. Organization owners cannot be moved from admin teams.
 * @summary Update user team membership
 */
export const organizationsControllerUpdateUserTeam = (
  id: string,
  userId: string,
  updateUserTeamDto: UpdateUserTeamDto,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${id}/users/${userId}/team`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateUserTeamDto,
  });
};

export const getOrganizationsControllerUpdateUserTeamMutationOptions = <
  TError = null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerUpdateUserTeam>>,
    TError,
    { id: string; userId: string; data: UpdateUserTeamDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerUpdateUserTeam>>,
  TError,
  { id: string; userId: string; data: UpdateUserTeamDto },
  TContext
> => {
  const mutationKey = ["organizationsControllerUpdateUserTeam"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerUpdateUserTeam>>,
    { id: string; userId: string; data: UpdateUserTeamDto }
  > = (props) => {
    const { id, userId, data } = props ?? {};

    return organizationsControllerUpdateUserTeam(id, userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerUpdateUserTeamMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerUpdateUserTeam>>
>;
export type OrganizationsControllerUpdateUserTeamMutationBody =
  UpdateUserTeamDto;
export type OrganizationsControllerUpdateUserTeamMutationError =
  | null
  | null
  | null
  | null;

/**
 * @summary Update user team membership
 */
export const useOrganizationsControllerUpdateUserTeam = <
  TError = null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerUpdateUserTeam>>,
      TError,
      { id: string; userId: string; data: UpdateUserTeamDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerUpdateUserTeam>>,
  TError,
  { id: string; userId: string; data: UpdateUserTeamDto },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerUpdateUserTeamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all members of an organization
 */
export const organizationsControllerGetOrganizationMembers = (
  id: string,
  signal?: AbortSignal,
) => {
  return customInstance<OrganizationMemberResponseDto[]>({
    url: `/api/v1/organizations/${id}/members`,
    method: "GET",
    signal,
  });
};

export const getOrganizationsControllerGetOrganizationMembersQueryKey = (
  id?: string,
) => {
  return [`/api/v1/organizations/${id}/members`] as const;
};

export const getOrganizationsControllerGetOrganizationMembersQueryOptions = <
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetOrganizationMembers>
  >,
  TError = null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetOrganizationMembers>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getOrganizationsControllerGetOrganizationMembersQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof organizationsControllerGetOrganizationMembers>>
  > = ({ signal }) => organizationsControllerGetOrganizationMembers(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsControllerGetOrganizationMembers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type OrganizationsControllerGetOrganizationMembersQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof organizationsControllerGetOrganizationMembers>>
  >;
export type OrganizationsControllerGetOrganizationMembersQueryError =
  | null
  | null;

export function useOrganizationsControllerGetOrganizationMembers<
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetOrganizationMembers>
  >,
  TError = null | null,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetOrganizationMembers>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof organizationsControllerGetOrganizationMembers>
          >,
          TError,
          Awaited<
            ReturnType<typeof organizationsControllerGetOrganizationMembers>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useOrganizationsControllerGetOrganizationMembers<
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetOrganizationMembers>
  >,
  TError = null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetOrganizationMembers>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof organizationsControllerGetOrganizationMembers>
          >,
          TError,
          Awaited<
            ReturnType<typeof organizationsControllerGetOrganizationMembers>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useOrganizationsControllerGetOrganizationMembers<
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetOrganizationMembers>
  >,
  TError = null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetOrganizationMembers>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all members of an organization
 */

export function useOrganizationsControllerGetOrganizationMembers<
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetOrganizationMembers>
  >,
  TError = null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetOrganizationMembers>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getOrganizationsControllerGetOrganizationMembersQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Invite a user to an organization
 */
export const organizationsControllerInviteUser = (
  organizationId: string,
  inviteUserDto: InviteUserDto,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${organizationId}/invite`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: inviteUserDto,
    signal,
  });
};

export const getOrganizationsControllerInviteUserMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerInviteUser>>,
    TError,
    { organizationId: string; data: InviteUserDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerInviteUser>>,
  TError,
  { organizationId: string; data: InviteUserDto },
  TContext
> => {
  const mutationKey = ["organizationsControllerInviteUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerInviteUser>>,
    { organizationId: string; data: InviteUserDto }
  > = (props) => {
    const { organizationId, data } = props ?? {};

    return organizationsControllerInviteUser(organizationId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerInviteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerInviteUser>>
>;
export type OrganizationsControllerInviteUserMutationBody = InviteUserDto;
export type OrganizationsControllerInviteUserMutationError = unknown;

/**
 * @summary Invite a user to an organization
 */
export const useOrganizationsControllerInviteUser = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerInviteUser>>,
      TError,
      { organizationId: string; data: InviteUserDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerInviteUser>>,
  TError,
  { organizationId: string; data: InviteUserDto },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerInviteUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Bulk invite users to an organization
 */
export const organizationsControllerBulkInviteUsers = (
  organizationId: string,
  bulkInviteUsersDto: BulkInviteUsersDto,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${organizationId}/bulk-invite`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: bulkInviteUsersDto,
    signal,
  });
};

export const getOrganizationsControllerBulkInviteUsersMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerBulkInviteUsers>>,
    TError,
    { organizationId: string; data: BulkInviteUsersDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerBulkInviteUsers>>,
  TError,
  { organizationId: string; data: BulkInviteUsersDto },
  TContext
> => {
  const mutationKey = ["organizationsControllerBulkInviteUsers"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerBulkInviteUsers>>,
    { organizationId: string; data: BulkInviteUsersDto }
  > = (props) => {
    const { organizationId, data } = props ?? {};

    return organizationsControllerBulkInviteUsers(organizationId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerBulkInviteUsersMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerBulkInviteUsers>>
>;
export type OrganizationsControllerBulkInviteUsersMutationBody =
  BulkInviteUsersDto;
export type OrganizationsControllerBulkInviteUsersMutationError = null;

/**
 * @summary Bulk invite users to an organization
 */
export const useOrganizationsControllerBulkInviteUsers = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerBulkInviteUsers>>,
      TError,
      { organizationId: string; data: BulkInviteUsersDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerBulkInviteUsers>>,
  TError,
  { organizationId: string; data: BulkInviteUsersDto },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerBulkInviteUsersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all pending invitations for the organization
 */
export const organizationsControllerGetPendingInvitations = (
  id: string,
  signal?: AbortSignal,
) => {
  return customInstance<PendingInvitationResponseDto[]>({
    url: `/api/v1/organizations/${id}/pending-invitations`,
    method: "GET",
    signal,
  });
};

export const getOrganizationsControllerGetPendingInvitationsQueryKey = (
  id?: string,
) => {
  return [`/api/v1/organizations/${id}/pending-invitations`] as const;
};

export const getOrganizationsControllerGetPendingInvitationsQueryOptions = <
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetPendingInvitations>
  >,
  TError = null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetPendingInvitations>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getOrganizationsControllerGetPendingInvitationsQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof organizationsControllerGetPendingInvitations>>
  > = ({ signal }) => organizationsControllerGetPendingInvitations(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof organizationsControllerGetPendingInvitations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type OrganizationsControllerGetPendingInvitationsQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof organizationsControllerGetPendingInvitations>>
  >;
export type OrganizationsControllerGetPendingInvitationsQueryError =
  | null
  | null;

export function useOrganizationsControllerGetPendingInvitations<
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetPendingInvitations>
  >,
  TError = null | null,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetPendingInvitations>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof organizationsControllerGetPendingInvitations>
          >,
          TError,
          Awaited<
            ReturnType<typeof organizationsControllerGetPendingInvitations>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useOrganizationsControllerGetPendingInvitations<
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetPendingInvitations>
  >,
  TError = null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetPendingInvitations>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof organizationsControllerGetPendingInvitations>
          >,
          TError,
          Awaited<
            ReturnType<typeof organizationsControllerGetPendingInvitations>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useOrganizationsControllerGetPendingInvitations<
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetPendingInvitations>
  >,
  TError = null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetPendingInvitations>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all pending invitations for the organization
 */

export function useOrganizationsControllerGetPendingInvitations<
  TData = Awaited<
    ReturnType<typeof organizationsControllerGetPendingInvitations>
  >,
  TError = null | null,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof organizationsControllerGetPendingInvitations>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getOrganizationsControllerGetPendingInvitationsQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Accept an organization invitation
 */
export const organizationsControllerAcceptInvitation = (
  acceptInvitationDto: AcceptInvitationDto,
  signal?: AbortSignal,
) => {
  return customInstance<AcceptInvitationResponseDto>({
    url: `/api/v1/organizations/accept-invitation`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: acceptInvitationDto,
    signal,
  });
};

export const getOrganizationsControllerAcceptInvitationMutationOptions = <
  TError = null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof organizationsControllerAcceptInvitation>>,
    TError,
    { data: AcceptInvitationDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof organizationsControllerAcceptInvitation>>,
  TError,
  { data: AcceptInvitationDto },
  TContext
> => {
  const mutationKey = ["organizationsControllerAcceptInvitation"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof organizationsControllerAcceptInvitation>>,
    { data: AcceptInvitationDto }
  > = (props) => {
    const { data } = props ?? {};

    return organizationsControllerAcceptInvitation(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type OrganizationsControllerAcceptInvitationMutationResult = NonNullable<
  Awaited<ReturnType<typeof organizationsControllerAcceptInvitation>>
>;
export type OrganizationsControllerAcceptInvitationMutationBody =
  AcceptInvitationDto;
export type OrganizationsControllerAcceptInvitationMutationError =
  | null
  | null
  | null
  | null;

/**
 * @summary Accept an organization invitation
 */
export const useOrganizationsControllerAcceptInvitation = <
  TError = null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof organizationsControllerAcceptInvitation>>,
      TError,
      { data: AcceptInvitationDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof organizationsControllerAcceptInvitation>>,
  TError,
  { data: AcceptInvitationDto },
  TContext
> => {
  const mutationOptions =
    getOrganizationsControllerAcceptInvitationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Creates a new team in the specified organization. The organization ID must be provided as a query parameter.
 * @summary Create a new team
 */
export const teamsControllerCreate = (
  createTeamsDto: CreateTeamsDto,
  params: TeamsControllerCreateParams,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/api/v1/teams`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createTeamsDto,
    params,
    signal,
  });
};

export const getTeamsControllerCreateMutationOptions = <
  TError = unknown | unknown | unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsControllerCreate>>,
    TError,
    { data: CreateTeamsDto; params: TeamsControllerCreateParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsControllerCreate>>,
  TError,
  { data: CreateTeamsDto; params: TeamsControllerCreateParams },
  TContext
> => {
  const mutationKey = ["teamsControllerCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsControllerCreate>>,
    { data: CreateTeamsDto; params: TeamsControllerCreateParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return teamsControllerCreate(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof teamsControllerCreate>>
>;
export type TeamsControllerCreateMutationBody = CreateTeamsDto;
export type TeamsControllerCreateMutationError = unknown | unknown | unknown;

/**
 * @summary Create a new team
 */
export const useTeamsControllerCreate = <
  TError = unknown | unknown | unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsControllerCreate>>,
      TError,
      { data: CreateTeamsDto; params: TeamsControllerCreateParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsControllerCreate>>,
  TError,
  { data: CreateTeamsDto; params: TeamsControllerCreateParams },
  TContext
> => {
  const mutationOptions = getTeamsControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves all teams that belong to the specified organization.
 * @summary Get all teams for an organization
 */
export const teamsControllerFindAll = (
  params: TeamsControllerFindAllParams,
  signal?: AbortSignal,
) => {
  return customInstance<TeamResponseDto[]>({
    url: `/api/v1/teams`,
    method: "GET",
    params,
    signal,
  });
};

export const getTeamsControllerFindAllQueryKey = (
  params?: TeamsControllerFindAllParams,
) => {
  return [`/api/v1/teams`, ...(params ? [params] : [])] as const;
};

export const getTeamsControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof teamsControllerFindAll>>,
  TError = null | null,
>(
  params: TeamsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTeamsControllerFindAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof teamsControllerFindAll>>
  > = ({ signal }) => teamsControllerFindAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof teamsControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type TeamsControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof teamsControllerFindAll>>
>;
export type TeamsControllerFindAllQueryError = null | null;

export function useTeamsControllerFindAll<
  TData = Awaited<ReturnType<typeof teamsControllerFindAll>>,
  TError = null | null,
>(
  params: TeamsControllerFindAllParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useTeamsControllerFindAll<
  TData = Awaited<ReturnType<typeof teamsControllerFindAll>>,
  TError = null | null,
>(
  params: TeamsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useTeamsControllerFindAll<
  TData = Awaited<ReturnType<typeof teamsControllerFindAll>>,
  TError = null | null,
>(
  params: TeamsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all teams for an organization
 */

export function useTeamsControllerFindAll<
  TData = Awaited<ReturnType<typeof teamsControllerFindAll>>,
  TError = null | null,
>(
  params: TeamsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getTeamsControllerFindAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a specific team by its ID within the specified organization.
 * @summary Get a team by id
 */
export const teamsControllerFindOne = (
  id: string,
  params: TeamsControllerFindOneParams,
  signal?: AbortSignal,
) => {
  return customInstance<TeamResponseDto>({
    url: `/api/v1/teams/${id}`,
    method: "GET",
    params,
    signal,
  });
};

export const getTeamsControllerFindOneQueryKey = (
  id?: string,
  params?: TeamsControllerFindOneParams,
) => {
  return [`/api/v1/teams/${id}`, ...(params ? [params] : [])] as const;
};

export const getTeamsControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof teamsControllerFindOne>>,
  TError = null | null | unknown,
>(
  id: string,
  params: TeamsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTeamsControllerFindOneQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof teamsControllerFindOne>>
  > = ({ signal }) => teamsControllerFindOne(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof teamsControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type TeamsControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof teamsControllerFindOne>>
>;
export type TeamsControllerFindOneQueryError = null | null | unknown;

export function useTeamsControllerFindOne<
  TData = Awaited<ReturnType<typeof teamsControllerFindOne>>,
  TError = null | null | unknown,
>(
  id: string,
  params: TeamsControllerFindOneParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useTeamsControllerFindOne<
  TData = Awaited<ReturnType<typeof teamsControllerFindOne>>,
  TError = null | null | unknown,
>(
  id: string,
  params: TeamsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof teamsControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useTeamsControllerFindOne<
  TData = Awaited<ReturnType<typeof teamsControllerFindOne>>,
  TError = null | null | unknown,
>(
  id: string,
  params: TeamsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get a team by id
 */

export function useTeamsControllerFindOne<
  TData = Awaited<ReturnType<typeof teamsControllerFindOne>>,
  TError = null | null | unknown,
>(
  id: string,
  params: TeamsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof teamsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getTeamsControllerFindOneQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates an existing team's information within the specified organization.
 * @summary Update a team
 */
export const teamsControllerUpdate = (
  id: string,
  updateTeamsDto: UpdateTeamsDto,
  params: TeamsControllerUpdateParams,
) => {
  return customInstance<unknown>({
    url: `/api/v1/teams/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateTeamsDto,
    params,
  });
};

export const getTeamsControllerUpdateMutationOptions = <
  TError = null | null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsControllerUpdate>>,
    TError,
    { id: string; data: UpdateTeamsDto; params: TeamsControllerUpdateParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsControllerUpdate>>,
  TError,
  { id: string; data: UpdateTeamsDto; params: TeamsControllerUpdateParams },
  TContext
> => {
  const mutationKey = ["teamsControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsControllerUpdate>>,
    { id: string; data: UpdateTeamsDto; params: TeamsControllerUpdateParams }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return teamsControllerUpdate(id, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof teamsControllerUpdate>>
>;
export type TeamsControllerUpdateMutationBody = UpdateTeamsDto;
export type TeamsControllerUpdateMutationError = null | null | null | null;

/**
 * @summary Update a team
 */
export const useTeamsControllerUpdate = <
  TError = null | null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsControllerUpdate>>,
      TError,
      { id: string; data: UpdateTeamsDto; params: TeamsControllerUpdateParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsControllerUpdate>>,
  TError,
  { id: string; data: UpdateTeamsDto; params: TeamsControllerUpdateParams },
  TContext
> => {
  const mutationOptions = getTeamsControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes a team from the specified organization. This action cannot be undone.
 * @summary Delete a team
 */
export const teamsControllerRemove = (
  id: string,
  params: TeamsControllerRemoveParams,
) => {
  return customInstance<unknown>({
    url: `/api/v1/teams/${id}`,
    method: "DELETE",
    params,
  });
};

export const getTeamsControllerRemoveMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsControllerRemove>>,
    TError,
    { id: string; params: TeamsControllerRemoveParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsControllerRemove>>,
  TError,
  { id: string; params: TeamsControllerRemoveParams },
  TContext
> => {
  const mutationKey = ["teamsControllerRemove"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsControllerRemove>>,
    { id: string; params: TeamsControllerRemoveParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return teamsControllerRemove(id, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof teamsControllerRemove>>
>;

export type TeamsControllerRemoveMutationError = null | null | null;

/**
 * @summary Delete a team
 */
export const useTeamsControllerRemove = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsControllerRemove>>,
      TError,
      { id: string; params: TeamsControllerRemoveParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsControllerRemove>>,
  TError,
  { id: string; params: TeamsControllerRemoveParams },
  TContext
> => {
  const mutationOptions = getTeamsControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all permissions for a team
 */
export const permissionsControllerGetTeamPermissions = (
  teamId: string,
  params: PermissionsControllerGetTeamPermissionsParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/permissions/${teamId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getPermissionsControllerGetTeamPermissionsQueryKey = (
  teamId?: string,
  params?: PermissionsControllerGetTeamPermissionsParams,
) => {
  return [
    `/api/v1/permissions/${teamId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPermissionsControllerGetTeamPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
  TError = null | null,
>(
  teamId: string,
  params: PermissionsControllerGetTeamPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPermissionsControllerGetTeamPermissionsQueryKey(teamId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>
  > = ({ signal }) =>
    permissionsControllerGetTeamPermissions(teamId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PermissionsControllerGetTeamPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>
>;
export type PermissionsControllerGetTeamPermissionsQueryError = null | null;

export function usePermissionsControllerGetTeamPermissions<
  TData = Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
  TError = null | null,
>(
  teamId: string,
  params: PermissionsControllerGetTeamPermissionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePermissionsControllerGetTeamPermissions<
  TData = Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
  TError = null | null,
>(
  teamId: string,
  params: PermissionsControllerGetTeamPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
          TError,
          Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePermissionsControllerGetTeamPermissions<
  TData = Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
  TError = null | null,
>(
  teamId: string,
  params: PermissionsControllerGetTeamPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all permissions for a team
 */

export function usePermissionsControllerGetTeamPermissions<
  TData = Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
  TError = null | null,
>(
  teamId: string,
  params: PermissionsControllerGetTeamPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof permissionsControllerGetTeamPermissions>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPermissionsControllerGetTeamPermissionsQueryOptions(
    teamId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all permissions for an organization
 */
export const permissionsControllerGetOrganizationPermissions = (
  params: PermissionsControllerGetOrganizationPermissionsParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/permissions`,
    method: "GET",
    params,
    signal,
  });
};

export const getPermissionsControllerGetOrganizationPermissionsQueryKey = (
  params?: PermissionsControllerGetOrganizationPermissionsParams,
) => {
  return [`/api/v1/permissions`, ...(params ? [params] : [])] as const;
};

export const getPermissionsControllerGetOrganizationPermissionsQueryOptions = <
  TData = Awaited<
    ReturnType<typeof permissionsControllerGetOrganizationPermissions>
  >,
  TError = null,
>(
  params: PermissionsControllerGetOrganizationPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof permissionsControllerGetOrganizationPermissions>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPermissionsControllerGetOrganizationPermissionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof permissionsControllerGetOrganizationPermissions>>
  > = ({ signal }) =>
    permissionsControllerGetOrganizationPermissions(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof permissionsControllerGetOrganizationPermissions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PermissionsControllerGetOrganizationPermissionsQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof permissionsControllerGetOrganizationPermissions>>
  >;
export type PermissionsControllerGetOrganizationPermissionsQueryError = null;

export function usePermissionsControllerGetOrganizationPermissions<
  TData = Awaited<
    ReturnType<typeof permissionsControllerGetOrganizationPermissions>
  >,
  TError = null,
>(
  params: PermissionsControllerGetOrganizationPermissionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof permissionsControllerGetOrganizationPermissions>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof permissionsControllerGetOrganizationPermissions>
          >,
          TError,
          Awaited<
            ReturnType<typeof permissionsControllerGetOrganizationPermissions>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePermissionsControllerGetOrganizationPermissions<
  TData = Awaited<
    ReturnType<typeof permissionsControllerGetOrganizationPermissions>
  >,
  TError = null,
>(
  params: PermissionsControllerGetOrganizationPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof permissionsControllerGetOrganizationPermissions>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof permissionsControllerGetOrganizationPermissions>
          >,
          TError,
          Awaited<
            ReturnType<typeof permissionsControllerGetOrganizationPermissions>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePermissionsControllerGetOrganizationPermissions<
  TData = Awaited<
    ReturnType<typeof permissionsControllerGetOrganizationPermissions>
  >,
  TError = null,
>(
  params: PermissionsControllerGetOrganizationPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof permissionsControllerGetOrganizationPermissions>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all permissions for an organization
 */

export function usePermissionsControllerGetOrganizationPermissions<
  TData = Awaited<
    ReturnType<typeof permissionsControllerGetOrganizationPermissions>
  >,
  TError = null,
>(
  params: PermissionsControllerGetOrganizationPermissionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof permissionsControllerGetOrganizationPermissions>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getPermissionsControllerGetOrganizationPermissionsQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create or update multiple permissions for a team at once. This endpoint supports both general resource type permissions (without resource_id) and specific resource permissions (with resource_id).
 * @summary Bulk set permissions for a team
 */
export const permissionsControllerBulkSetTeamPermissions = (
  teamId: string,
  bulkSetTeamPermissionsDto: BulkSetTeamPermissionsDto[],
  params: PermissionsControllerBulkSetTeamPermissionsParams,
) => {
  return customInstance<Permissions[]>({
    url: `/api/v1/permissions/${teamId}/bulk`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: bulkSetTeamPermissionsDto,
    params,
  });
};

export const getPermissionsControllerBulkSetTeamPermissionsMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof permissionsControllerBulkSetTeamPermissions>>,
    TError,
    {
      teamId: string;
      data: BulkSetTeamPermissionsDto[];
      params: PermissionsControllerBulkSetTeamPermissionsParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof permissionsControllerBulkSetTeamPermissions>>,
  TError,
  {
    teamId: string;
    data: BulkSetTeamPermissionsDto[];
    params: PermissionsControllerBulkSetTeamPermissionsParams;
  },
  TContext
> => {
  const mutationKey = ["permissionsControllerBulkSetTeamPermissions"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof permissionsControllerBulkSetTeamPermissions>>,
    {
      teamId: string;
      data: BulkSetTeamPermissionsDto[];
      params: PermissionsControllerBulkSetTeamPermissionsParams;
    }
  > = (props) => {
    const { teamId, data, params } = props ?? {};

    return permissionsControllerBulkSetTeamPermissions(teamId, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PermissionsControllerBulkSetTeamPermissionsMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof permissionsControllerBulkSetTeamPermissions>>
  >;
export type PermissionsControllerBulkSetTeamPermissionsMutationBody =
  BulkSetTeamPermissionsDto[];
export type PermissionsControllerBulkSetTeamPermissionsMutationError =
  | null
  | null
  | null;

/**
 * @summary Bulk set permissions for a team
 */
export const usePermissionsControllerBulkSetTeamPermissions = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof permissionsControllerBulkSetTeamPermissions>>,
      TError,
      {
        teamId: string;
        data: BulkSetTeamPermissionsDto[];
        params: PermissionsControllerBulkSetTeamPermissionsParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof permissionsControllerBulkSetTeamPermissions>>,
  TError,
  {
    teamId: string;
    data: BulkSetTeamPermissionsDto[];
    params: PermissionsControllerBulkSetTeamPermissionsParams;
  },
  TContext
> => {
  const mutationOptions =
    getPermissionsControllerBulkSetTeamPermissionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Public endpoint to retrieve all pricing plans, features, and addon bundles for frontend/website use
 * @summary Get complete pricing configuration
 */
export const pricingControllerGetPricingConfiguration = (
  signal?: AbortSignal,
) => {
  return customInstance<PricingConfigurationDto>({
    url: `/api/v1/pricing/configuration`,
    method: "GET",
    signal,
  });
};

export const getPricingControllerGetPricingConfigurationQueryKey = () => {
  return [`/api/v1/pricing/configuration`] as const;
};

export const getPricingControllerGetPricingConfigurationQueryOptions = <
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPricingControllerGetPricingConfigurationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>
  > = ({ signal }) => pricingControllerGetPricingConfiguration(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PricingControllerGetPricingConfigurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>
>;
export type PricingControllerGetPricingConfigurationQueryError = unknown;

export function usePricingControllerGetPricingConfiguration<
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
          TError,
          Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePricingControllerGetPricingConfiguration<
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
          TError,
          Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePricingControllerGetPricingConfiguration<
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get complete pricing configuration
 */

export function usePricingControllerGetPricingConfiguration<
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPricingConfiguration>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getPricingControllerGetPricingConfigurationQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all active pricing plans with their features
 * @summary Get all pricing plans
 */
export const pricingControllerGetPricingPlans = (signal?: AbortSignal) => {
  return customInstance<PricingPlanDto[]>({
    url: `/api/v1/pricing/plans`,
    method: "GET",
    signal,
  });
};

export const getPricingControllerGetPricingPlansQueryKey = () => {
  return [`/api/v1/pricing/plans`] as const;
};

export const getPricingControllerGetPricingPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPricingControllerGetPricingPlansQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>
  > = ({ signal }) => pricingControllerGetPricingPlans(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PricingControllerGetPricingPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>
>;
export type PricingControllerGetPricingPlansQueryError = unknown;

export function usePricingControllerGetPricingPlans<
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
          TError,
          Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePricingControllerGetPricingPlans<
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
          TError,
          Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePricingControllerGetPricingPlans<
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all pricing plans
 */

export function usePricingControllerGetPricingPlans<
  TData = Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPricingPlans>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPricingControllerGetPricingPlansQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get a specific pricing plan by its tier (personal, business, company, custom)
 * @summary Get pricing plan by tier
 */
export const pricingControllerGetPlanByTier = (
  tier: string,
  signal?: AbortSignal,
) => {
  return customInstance<PricingPlanDto>({
    url: `/api/v1/pricing/plans/${tier}`,
    method: "GET",
    signal,
  });
};

export const getPricingControllerGetPlanByTierQueryKey = (tier?: string) => {
  return [`/api/v1/pricing/plans/${tier}`] as const;
};

export const getPricingControllerGetPlanByTierQueryOptions = <
  TData = Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
  TError = null,
>(
  tier: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPricingControllerGetPlanByTierQueryKey(tier);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>
  > = ({ signal }) => pricingControllerGetPlanByTier(tier, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!tier,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PricingControllerGetPlanByTierQueryResult = NonNullable<
  Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>
>;
export type PricingControllerGetPlanByTierQueryError = null;

export function usePricingControllerGetPlanByTier<
  TData = Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
  TError = null,
>(
  tier: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
          TError,
          Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePricingControllerGetPlanByTier<
  TData = Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
  TError = null,
>(
  tier: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
          TError,
          Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePricingControllerGetPlanByTier<
  TData = Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
  TError = null,
>(
  tier: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get pricing plan by tier
 */

export function usePricingControllerGetPlanByTier<
  TData = Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
  TError = null,
>(
  tier: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetPlanByTier>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPricingControllerGetPlanByTierQueryOptions(
    tier,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all available addon bundles for additional call minutes
 * @summary Get addon bundles
 */
export const pricingControllerGetAddonBundles = (signal?: AbortSignal) => {
  return customInstance<null>({
    url: `/api/v1/pricing/addon-bundles`,
    method: "GET",
    signal,
  });
};

export const getPricingControllerGetAddonBundlesQueryKey = () => {
  return [`/api/v1/pricing/addon-bundles`] as const;
};

export const getPricingControllerGetAddonBundlesQueryOptions = <
  TData = Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPricingControllerGetAddonBundlesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>
  > = ({ signal }) => pricingControllerGetAddonBundles(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PricingControllerGetAddonBundlesQueryResult = NonNullable<
  Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>
>;
export type PricingControllerGetAddonBundlesQueryError = unknown;

export function usePricingControllerGetAddonBundles<
  TData = Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
          TError,
          Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePricingControllerGetAddonBundles<
  TData = Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
          TError,
          Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePricingControllerGetAddonBundles<
  TData = Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get addon bundles
 */

export function usePricingControllerGetAddonBundles<
  TData = Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof pricingControllerGetAddonBundles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPricingControllerGetAddonBundlesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Schedule an upcoming meeting
 */
export const meetingsControllerScheduleMeeting = (
  scheduleMeetingDto: ScheduleMeetingDto,
  params: MeetingsControllerScheduleMeetingParams,
  signal?: AbortSignal,
) => {
  return customInstance<ScheduleMeetingResponseDto>({
    url: `/api/v1/meetings/schedule`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: scheduleMeetingDto,
    params,
    signal,
  });
};

export const getMeetingsControllerScheduleMeetingMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerScheduleMeeting>>,
    TError,
    {
      data: ScheduleMeetingDto;
      params: MeetingsControllerScheduleMeetingParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerScheduleMeeting>>,
  TError,
  { data: ScheduleMeetingDto; params: MeetingsControllerScheduleMeetingParams },
  TContext
> => {
  const mutationKey = ["meetingsControllerScheduleMeeting"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerScheduleMeeting>>,
    {
      data: ScheduleMeetingDto;
      params: MeetingsControllerScheduleMeetingParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return meetingsControllerScheduleMeeting(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerScheduleMeetingMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerScheduleMeeting>>
>;
export type MeetingsControllerScheduleMeetingMutationBody = ScheduleMeetingDto;
export type MeetingsControllerScheduleMeetingMutationError = null | null | null;

/**
 * @summary Schedule an upcoming meeting
 */
export const useMeetingsControllerScheduleMeeting = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerScheduleMeeting>>,
      TError,
      {
        data: ScheduleMeetingDto;
        params: MeetingsControllerScheduleMeetingParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerScheduleMeeting>>,
  TError,
  { data: ScheduleMeetingDto; params: MeetingsControllerScheduleMeetingParams },
  TContext
> => {
  const mutationOptions =
    getMeetingsControllerScheduleMeetingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all meetings with pagination
 */
export const meetingsControllerFindAll = (
  params: MeetingsControllerFindAllParams,
  signal?: AbortSignal,
) => {
  return customInstance<PaginatedMeetingsResponseDto>({
    url: `/api/v1/meetings`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerFindAllQueryKey = (
  params?: MeetingsControllerFindAllParams,
) => {
  return [`/api/v1/meetings`, ...(params ? [params] : [])] as const;
};

export const getMeetingsControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerFindAll>>,
  TError = null | null,
>(
  params: MeetingsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMeetingsControllerFindAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerFindAll>>
  > = ({ signal }) => meetingsControllerFindAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerFindAll>>
>;
export type MeetingsControllerFindAllQueryError = null | null;

export function useMeetingsControllerFindAll<
  TData = Awaited<ReturnType<typeof meetingsControllerFindAll>>,
  TError = null | null,
>(
  params: MeetingsControllerFindAllParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerFindAll<
  TData = Awaited<ReturnType<typeof meetingsControllerFindAll>>,
  TError = null | null,
>(
  params: MeetingsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerFindAll<
  TData = Awaited<ReturnType<typeof meetingsControllerFindAll>>,
  TError = null | null,
>(
  params: MeetingsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all meetings with pagination
 */

export function useMeetingsControllerFindAll<
  TData = Awaited<ReturnType<typeof meetingsControllerFindAll>>,
  TError = null | null,
>(
  params: MeetingsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerFindAllQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns upcoming calendar events that have been scheduled for bot recording
 * @summary Get upcoming scheduled events for bot joining
 */
export const meetingsControllerGetUpcomingScheduledEvents = (
  params: MeetingsControllerGetUpcomingScheduledEventsParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingsControllerGetUpcomingScheduledEvents200>({
    url: `/api/v1/meetings/upcoming-scheduled`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerGetUpcomingScheduledEventsQueryKey = (
  params?: MeetingsControllerGetUpcomingScheduledEventsParams,
) => {
  return [
    `/api/v1/meetings/upcoming-scheduled`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMeetingsControllerGetUpcomingScheduledEventsQueryOptions = <
  TData = Awaited<
    ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
  >,
  TError = null | null | null,
>(
  params: MeetingsControllerGetUpcomingScheduledEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMeetingsControllerGetUpcomingScheduledEventsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>>
  > = ({ signal }) =>
    meetingsControllerGetUpcomingScheduledEvents(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerGetUpcomingScheduledEventsQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>>
  >;
export type MeetingsControllerGetUpcomingScheduledEventsQueryError =
  | null
  | null
  | null;

export function useMeetingsControllerGetUpcomingScheduledEvents<
  TData = Awaited<
    ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
  >,
  TError = null | null | null,
>(
  params: MeetingsControllerGetUpcomingScheduledEventsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
          >,
          TError,
          Awaited<
            ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerGetUpcomingScheduledEvents<
  TData = Awaited<
    ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
  >,
  TError = null | null | null,
>(
  params: MeetingsControllerGetUpcomingScheduledEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
          >,
          TError,
          Awaited<
            ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerGetUpcomingScheduledEvents<
  TData = Awaited<
    ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
  >,
  TError = null | null | null,
>(
  params: MeetingsControllerGetUpcomingScheduledEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get upcoming scheduled events for bot joining
 */

export function useMeetingsControllerGetUpcomingScheduledEvents<
  TData = Awaited<
    ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
  >,
  TError = null | null | null,
>(
  params: MeetingsControllerGetUpcomingScheduledEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof meetingsControllerGetUpcomingScheduledEvents>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getMeetingsControllerGetUpcomingScheduledEventsQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the next scheduled calendar event that a bot will join for recording
 * @summary Get the next immediate event that a bot will join
 */
export const meetingsControllerGetNextBotEvent = (
  params: MeetingsControllerGetNextBotEventParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingsControllerGetNextBotEvent200>({
    url: `/api/v1/meetings/next-bot-event`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerGetNextBotEventQueryKey = (
  params?: MeetingsControllerGetNextBotEventParams,
) => {
  return [
    `/api/v1/meetings/next-bot-event`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMeetingsControllerGetNextBotEventQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
  TError = null | null | null,
>(
  params: MeetingsControllerGetNextBotEventParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMeetingsControllerGetNextBotEventQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>
  > = ({ signal }) => meetingsControllerGetNextBotEvent(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerGetNextBotEventQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>
>;
export type MeetingsControllerGetNextBotEventQueryError = null | null | null;

export function useMeetingsControllerGetNextBotEvent<
  TData = Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
  TError = null | null | null,
>(
  params: MeetingsControllerGetNextBotEventParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerGetNextBotEvent<
  TData = Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
  TError = null | null | null,
>(
  params: MeetingsControllerGetNextBotEventParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerGetNextBotEvent<
  TData = Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
  TError = null | null | null,
>(
  params: MeetingsControllerGetNextBotEventParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get the next immediate event that a bot will join
 */

export function useMeetingsControllerGetNextBotEvent<
  TData = Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
  TError = null | null | null,
>(
  params: MeetingsControllerGetNextBotEventParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetNextBotEvent>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerGetNextBotEventQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a meeting details by id
 */
export const meetingsControllerFindOne = (
  id: string,
  params: MeetingsControllerFindOneParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingResponseDto>({
    url: `/api/v1/meetings/${id}`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerFindOneQueryKey = (
  id?: string,
  params?: MeetingsControllerFindOneParams,
) => {
  return [`/api/v1/meetings/${id}`, ...(params ? [params] : [])] as const;
};

export const getMeetingsControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMeetingsControllerFindOneQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerFindOne>>
  > = ({ signal }) => meetingsControllerFindOne(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerFindOne>>
>;
export type MeetingsControllerFindOneQueryError = null | null | null;

export function useMeetingsControllerFindOne<
  TData = Awaited<ReturnType<typeof meetingsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerFindOneParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerFindOne<
  TData = Awaited<ReturnType<typeof meetingsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerFindOne<
  TData = Awaited<ReturnType<typeof meetingsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get a meeting details by id
 */

export function useMeetingsControllerFindOne<
  TData = Awaited<ReturnType<typeof meetingsControllerFindOne>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerFindOneQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a meeting
 */
export const meetingsControllerUpdate = (
  id: string,
  updateMeetingDto: UpdateMeetingDto,
  params: MeetingsControllerUpdateParams,
) => {
  return customInstance<MeetingResponseDto>({
    url: `/api/v1/meetings/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateMeetingDto,
    params,
  });
};

export const getMeetingsControllerUpdateMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerUpdate>>,
    TError,
    {
      id: string;
      data: UpdateMeetingDto;
      params: MeetingsControllerUpdateParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerUpdate>>,
  TError,
  {
    id: string;
    data: UpdateMeetingDto;
    params: MeetingsControllerUpdateParams;
  },
  TContext
> => {
  const mutationKey = ["meetingsControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerUpdate>>,
    {
      id: string;
      data: UpdateMeetingDto;
      params: MeetingsControllerUpdateParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return meetingsControllerUpdate(id, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerUpdate>>
>;
export type MeetingsControllerUpdateMutationBody = UpdateMeetingDto;
export type MeetingsControllerUpdateMutationError = null | null | null;

/**
 * @summary Update a meeting
 */
export const useMeetingsControllerUpdate = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerUpdate>>,
      TError,
      {
        id: string;
        data: UpdateMeetingDto;
        params: MeetingsControllerUpdateParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerUpdate>>,
  TError,
  {
    id: string;
    data: UpdateMeetingDto;
    params: MeetingsControllerUpdateParams;
  },
  TContext
> => {
  const mutationOptions = getMeetingsControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a meeting
 */
export const meetingsControllerDelete = (
  id: string,
  params: MeetingsControllerDeleteParams,
) => {
  return customInstance<null>({
    url: `/api/v1/meetings/${id}`,
    method: "DELETE",
    params,
  });
};

export const getMeetingsControllerDeleteMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerDelete>>,
    TError,
    { id: string; params: MeetingsControllerDeleteParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerDelete>>,
  TError,
  { id: string; params: MeetingsControllerDeleteParams },
  TContext
> => {
  const mutationKey = ["meetingsControllerDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerDelete>>,
    { id: string; params: MeetingsControllerDeleteParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return meetingsControllerDelete(id, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerDelete>>
>;

export type MeetingsControllerDeleteMutationError = null | null | null;

/**
 * @summary Delete a meeting
 */
export const useMeetingsControllerDelete = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerDelete>>,
      TError,
      { id: string; params: MeetingsControllerDeleteParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerDelete>>,
  TError,
  { id: string; params: MeetingsControllerDeleteParams },
  TContext
> => {
  const mutationOptions = getMeetingsControllerDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Complete a meeting
 */
export const meetingsControllerCompleteMeeting = (
  id: string,
  completeMeetingDto: CompleteMeetingDto,
  params: MeetingsControllerCompleteMeetingParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingResponseDto>({
    url: `/api/v1/meetings/${id}/complete`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: completeMeetingDto,
    params,
    signal,
  });
};

export const getMeetingsControllerCompleteMeetingMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerCompleteMeeting>>,
    TError,
    {
      id: string;
      data: CompleteMeetingDto;
      params: MeetingsControllerCompleteMeetingParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerCompleteMeeting>>,
  TError,
  {
    id: string;
    data: CompleteMeetingDto;
    params: MeetingsControllerCompleteMeetingParams;
  },
  TContext
> => {
  const mutationKey = ["meetingsControllerCompleteMeeting"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerCompleteMeeting>>,
    {
      id: string;
      data: CompleteMeetingDto;
      params: MeetingsControllerCompleteMeetingParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return meetingsControllerCompleteMeeting(id, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerCompleteMeetingMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerCompleteMeeting>>
>;
export type MeetingsControllerCompleteMeetingMutationBody = CompleteMeetingDto;
export type MeetingsControllerCompleteMeetingMutationError = null | null | null;

/**
 * @summary Complete a meeting
 */
export const useMeetingsControllerCompleteMeeting = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerCompleteMeeting>>,
      TError,
      {
        id: string;
        data: CompleteMeetingDto;
        params: MeetingsControllerCompleteMeetingParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerCompleteMeeting>>,
  TError,
  {
    id: string;
    data: CompleteMeetingDto;
    params: MeetingsControllerCompleteMeetingParams;
  },
  TContext
> => {
  const mutationOptions =
    getMeetingsControllerCompleteMeetingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Add to live meeting
 */
export const meetingsControllerAddToLiveMeeting = (
  addToLiveMeetingDto: AddToLiveMeetingDto,
  params: MeetingsControllerAddToLiveMeetingParams,
  signal?: AbortSignal,
) => {
  return customInstance<AddToLiveMeetingResponseDto>({
    url: `/api/v1/meetings/add-to-live-meeting`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: addToLiveMeetingDto,
    params,
    signal,
  });
};

export const getMeetingsControllerAddToLiveMeetingMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerAddToLiveMeeting>>,
    TError,
    {
      data: AddToLiveMeetingDto;
      params: MeetingsControllerAddToLiveMeetingParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerAddToLiveMeeting>>,
  TError,
  {
    data: AddToLiveMeetingDto;
    params: MeetingsControllerAddToLiveMeetingParams;
  },
  TContext
> => {
  const mutationKey = ["meetingsControllerAddToLiveMeeting"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerAddToLiveMeeting>>,
    {
      data: AddToLiveMeetingDto;
      params: MeetingsControllerAddToLiveMeetingParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return meetingsControllerAddToLiveMeeting(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerAddToLiveMeetingMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerAddToLiveMeeting>>
>;
export type MeetingsControllerAddToLiveMeetingMutationBody =
  AddToLiveMeetingDto;
export type MeetingsControllerAddToLiveMeetingMutationError =
  | null
  | null
  | null;

/**
 * @summary Add to live meeting
 */
export const useMeetingsControllerAddToLiveMeeting = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerAddToLiveMeeting>>,
      TError,
      {
        data: AddToLiveMeetingDto;
        params: MeetingsControllerAddToLiveMeetingParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerAddToLiveMeeting>>,
  TError,
  {
    data: AddToLiveMeetingDto;
    params: MeetingsControllerAddToLiveMeetingParams;
  },
  TContext
> => {
  const mutationOptions =
    getMeetingsControllerAddToLiveMeetingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get a signed URL to access a meeting's video. Only works for videos stored in Supabase storage.
 * @summary Get signed video URL for authenticated access
 */
export const meetingsControllerGetMeetingVideoUrl = (
  id: string,
  params: MeetingsControllerGetMeetingVideoUrlParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingsControllerGetMeetingVideoUrl200>({
    url: `/api/v1/meetings/${id}/video-url`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerGetMeetingVideoUrlQueryKey = (
  id?: string,
  params?: MeetingsControllerGetMeetingVideoUrlParams,
) => {
  return [
    `/api/v1/meetings/${id}/video-url`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMeetingsControllerGetMeetingVideoUrlQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingVideoUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMeetingsControllerGetMeetingVideoUrlQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>
  > = ({ signal }) => meetingsControllerGetMeetingVideoUrl(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerGetMeetingVideoUrlQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>
>;
export type MeetingsControllerGetMeetingVideoUrlQueryError = null | null;

export function useMeetingsControllerGetMeetingVideoUrl<
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingVideoUrlParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerGetMeetingVideoUrl<
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingVideoUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerGetMeetingVideoUrl<
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingVideoUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get signed video URL for authenticated access
 */

export function useMeetingsControllerGetMeetingVideoUrl<
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingVideoUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingVideoUrl>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerGetMeetingVideoUrlQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Stream a meeting's video with proper security checks and support for HLS/progressive streaming
 * @summary Stream meeting video with security
 */
export const meetingsControllerStreamMeetingVideo = (
  id: string,
  params: MeetingsControllerStreamMeetingVideoParams,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/api/v1/meetings/${id}/video-stream`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerStreamMeetingVideoQueryKey = (
  id?: string,
  params?: MeetingsControllerStreamMeetingVideoParams,
) => {
  return [
    `/api/v1/meetings/${id}/video-stream`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMeetingsControllerStreamMeetingVideoQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerStreamMeetingVideoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMeetingsControllerStreamMeetingVideoQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>
  > = ({ signal }) => meetingsControllerStreamMeetingVideo(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerStreamMeetingVideoQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>
>;
export type MeetingsControllerStreamMeetingVideoQueryError = null | null;

export function useMeetingsControllerStreamMeetingVideo<
  TData = Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerStreamMeetingVideoParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerStreamMeetingVideo<
  TData = Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerStreamMeetingVideoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerStreamMeetingVideo<
  TData = Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerStreamMeetingVideoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Stream meeting video with security
 */

export function useMeetingsControllerStreamMeetingVideo<
  TData = Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerStreamMeetingVideoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerStreamMeetingVideoQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get shared meeting data (public endpoint)
 */
export const meetingsControllerGetSharedMeeting = (
  id: string,
  params: MeetingsControllerGetSharedMeetingParams,
  signal?: AbortSignal,
) => {
  return customInstance<Meetings>({
    url: `/api/v1/meetings/${id}/shared`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerGetSharedMeetingQueryKey = (
  id?: string,
  params?: MeetingsControllerGetSharedMeetingParams,
) => {
  return [
    `/api/v1/meetings/${id}/shared`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMeetingsControllerGetSharedMeetingQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerGetSharedMeetingParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMeetingsControllerGetSharedMeetingQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>
  > = ({ signal }) => meetingsControllerGetSharedMeeting(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerGetSharedMeetingQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>
>;
export type MeetingsControllerGetSharedMeetingQueryError = null;

export function useMeetingsControllerGetSharedMeeting<
  TData = Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerGetSharedMeetingParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerGetSharedMeeting<
  TData = Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerGetSharedMeetingParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerGetSharedMeeting<
  TData = Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerGetSharedMeetingParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get shared meeting data (public endpoint)
 */

export function useMeetingsControllerGetSharedMeeting<
  TData = Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerGetSharedMeetingParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetSharedMeeting>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerGetSharedMeetingQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get a secure URL for streaming a meeting's video with format and quality options
 * @summary Get secure streaming URL for meeting video
 */
export const meetingsControllerGetMeetingStreamingUrl = (
  id: string,
  params: MeetingsControllerGetMeetingStreamingUrlParams,
  signal?: AbortSignal,
) => {
  return customInstance<VideoStreamResponseDto>({
    url: `/api/v1/meetings/${id}/streaming-url`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerGetMeetingStreamingUrlQueryKey = (
  id?: string,
  params?: MeetingsControllerGetMeetingStreamingUrlParams,
) => {
  return [
    `/api/v1/meetings/${id}/streaming-url`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMeetingsControllerGetMeetingStreamingUrlQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingStreamingUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMeetingsControllerGetMeetingStreamingUrlQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>
  > = ({ signal }) =>
    meetingsControllerGetMeetingStreamingUrl(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerGetMeetingStreamingUrlQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>
>;
export type MeetingsControllerGetMeetingStreamingUrlQueryError = null | null;

export function useMeetingsControllerGetMeetingStreamingUrl<
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingStreamingUrlParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerGetMeetingStreamingUrl<
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingStreamingUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerGetMeetingStreamingUrl<
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingStreamingUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get secure streaming URL for meeting video
 */

export function useMeetingsControllerGetMeetingStreamingUrl<
  TData = Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
  TError = null | null,
>(
  id: string,
  params: MeetingsControllerGetMeetingStreamingUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetMeetingStreamingUrl>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerGetMeetingStreamingUrlQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Submit complete meeting data including transcript, summary, and metadata. Works as upsert - creates new meeting if no meeting_id provided, updates existing if meeting_id provided.
 * @summary Complete meeting data with API key authentication
 */
export const meetingsControllerSubmitCompleteMeetingData = (
  params: MeetingsControllerSubmitCompleteMeetingDataParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingsControllerSubmitCompleteMeetingData200>({
    url: `/api/v1/meetings/complete-meeting-data`,
    method: "POST",
    params,
    signal,
  });
};

export const getMeetingsControllerSubmitCompleteMeetingDataMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerSubmitCompleteMeetingData>>,
    TError,
    { params: MeetingsControllerSubmitCompleteMeetingDataParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerSubmitCompleteMeetingData>>,
  TError,
  { params: MeetingsControllerSubmitCompleteMeetingDataParams },
  TContext
> => {
  const mutationKey = ["meetingsControllerSubmitCompleteMeetingData"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerSubmitCompleteMeetingData>>,
    { params: MeetingsControllerSubmitCompleteMeetingDataParams }
  > = (props) => {
    const { params } = props ?? {};

    return meetingsControllerSubmitCompleteMeetingData(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerSubmitCompleteMeetingDataMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof meetingsControllerSubmitCompleteMeetingData>>
  >;

export type MeetingsControllerSubmitCompleteMeetingDataMutationError =
  | null
  | null;

/**
 * @summary Complete meeting data with API key authentication
 */
export const useMeetingsControllerSubmitCompleteMeetingData = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerSubmitCompleteMeetingData>>,
      TError,
      { params: MeetingsControllerSubmitCompleteMeetingDataParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerSubmitCompleteMeetingData>>,
  TError,
  { params: MeetingsControllerSubmitCompleteMeetingDataParams },
  TContext
> => {
  const mutationOptions =
    getMeetingsControllerSubmitCompleteMeetingDataMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create a share link for a meeting
 */
export const meetingsControllerCreateShareLink = (
  id: string,
  createMeetingShareDto: CreateMeetingShareDto,
  params: MeetingsControllerCreateShareLinkParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingShareResponseDto>({
    url: `/api/v1/meetings/${id}/share`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createMeetingShareDto,
    params,
    signal,
  });
};

export const getMeetingsControllerCreateShareLinkMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerCreateShareLink>>,
    TError,
    {
      id: string;
      data: CreateMeetingShareDto;
      params: MeetingsControllerCreateShareLinkParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerCreateShareLink>>,
  TError,
  {
    id: string;
    data: CreateMeetingShareDto;
    params: MeetingsControllerCreateShareLinkParams;
  },
  TContext
> => {
  const mutationKey = ["meetingsControllerCreateShareLink"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerCreateShareLink>>,
    {
      id: string;
      data: CreateMeetingShareDto;
      params: MeetingsControllerCreateShareLinkParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return meetingsControllerCreateShareLink(id, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerCreateShareLinkMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerCreateShareLink>>
>;
export type MeetingsControllerCreateShareLinkMutationBody =
  CreateMeetingShareDto;
export type MeetingsControllerCreateShareLinkMutationError = null | null | null;

/**
 * @summary Create a share link for a meeting
 */
export const useMeetingsControllerCreateShareLink = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerCreateShareLink>>,
      TError,
      {
        id: string;
        data: CreateMeetingShareDto;
        params: MeetingsControllerCreateShareLinkParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerCreateShareLink>>,
  TError,
  {
    id: string;
    data: CreateMeetingShareDto;
    params: MeetingsControllerCreateShareLinkParams;
  },
  TContext
> => {
  const mutationOptions =
    getMeetingsControllerCreateShareLinkMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get share link for a meeting
 */
export const meetingsControllerGetShareLink = (
  id: string,
  params: MeetingsControllerGetShareLinkParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingShareResponseDto>({
    url: `/api/v1/meetings/${id}/share`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerGetShareLinkQueryKey = (
  id?: string,
  params?: MeetingsControllerGetShareLinkParams,
) => {
  return [`/api/v1/meetings/${id}/share`, ...(params ? [params] : [])] as const;
};

export const getMeetingsControllerGetShareLinkQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerGetShareLinkParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMeetingsControllerGetShareLinkQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerGetShareLink>>
  > = ({ signal }) => meetingsControllerGetShareLink(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerGetShareLinkQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerGetShareLink>>
>;
export type MeetingsControllerGetShareLinkQueryError = null | null | null;

export function useMeetingsControllerGetShareLink<
  TData = Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerGetShareLinkParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetShareLink>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerGetShareLink<
  TData = Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerGetShareLinkParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerGetShareLink>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerGetShareLink<
  TData = Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerGetShareLinkParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get share link for a meeting
 */

export function useMeetingsControllerGetShareLink<
  TData = Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
  TError = null | null | null,
>(
  id: string,
  params: MeetingsControllerGetShareLinkParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerGetShareLink>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerGetShareLinkQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update share link settings
 */
export const meetingsControllerUpdateShareLink = (
  id: string,
  updateMeetingShareDto: UpdateMeetingShareDto,
  params: MeetingsControllerUpdateShareLinkParams,
) => {
  return customInstance<MeetingShareResponseDto>({
    url: `/api/v1/meetings/${id}/share`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateMeetingShareDto,
    params,
  });
};

export const getMeetingsControllerUpdateShareLinkMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerUpdateShareLink>>,
    TError,
    {
      id: string;
      data: UpdateMeetingShareDto;
      params: MeetingsControllerUpdateShareLinkParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerUpdateShareLink>>,
  TError,
  {
    id: string;
    data: UpdateMeetingShareDto;
    params: MeetingsControllerUpdateShareLinkParams;
  },
  TContext
> => {
  const mutationKey = ["meetingsControllerUpdateShareLink"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerUpdateShareLink>>,
    {
      id: string;
      data: UpdateMeetingShareDto;
      params: MeetingsControllerUpdateShareLinkParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return meetingsControllerUpdateShareLink(id, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerUpdateShareLinkMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerUpdateShareLink>>
>;
export type MeetingsControllerUpdateShareLinkMutationBody =
  UpdateMeetingShareDto;
export type MeetingsControllerUpdateShareLinkMutationError = null | null | null;

/**
 * @summary Update share link settings
 */
export const useMeetingsControllerUpdateShareLink = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerUpdateShareLink>>,
      TError,
      {
        id: string;
        data: UpdateMeetingShareDto;
        params: MeetingsControllerUpdateShareLinkParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerUpdateShareLink>>,
  TError,
  {
    id: string;
    data: UpdateMeetingShareDto;
    params: MeetingsControllerUpdateShareLinkParams;
  },
  TContext
> => {
  const mutationOptions =
    getMeetingsControllerUpdateShareLinkMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete share link for a meeting
 */
export const meetingsControllerDeleteShareLink = (
  id: string,
  params: MeetingsControllerDeleteShareLinkParams,
) => {
  return customInstance<null>({
    url: `/api/v1/meetings/${id}/share`,
    method: "DELETE",
    params,
  });
};

export const getMeetingsControllerDeleteShareLinkMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingsControllerDeleteShareLink>>,
    TError,
    { id: string; params: MeetingsControllerDeleteShareLinkParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingsControllerDeleteShareLink>>,
  TError,
  { id: string; params: MeetingsControllerDeleteShareLinkParams },
  TContext
> => {
  const mutationKey = ["meetingsControllerDeleteShareLink"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingsControllerDeleteShareLink>>,
    { id: string; params: MeetingsControllerDeleteShareLinkParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return meetingsControllerDeleteShareLink(id, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingsControllerDeleteShareLinkMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerDeleteShareLink>>
>;

export type MeetingsControllerDeleteShareLinkMutationError = null | null | null;

/**
 * @summary Delete share link for a meeting
 */
export const useMeetingsControllerDeleteShareLink = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingsControllerDeleteShareLink>>,
      TError,
      { id: string; params: MeetingsControllerDeleteShareLinkParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingsControllerDeleteShareLink>>,
  TError,
  { id: string; params: MeetingsControllerDeleteShareLinkParams },
  TContext
> => {
  const mutationOptions =
    getMeetingsControllerDeleteShareLinkMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Validate a share token for a meeting
 */
export const meetingsControllerValidateShareToken = (
  id: string,
  params: MeetingsControllerValidateShareTokenParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingsControllerValidateShareToken200>({
    url: `/api/v1/meetings/${id}/share/validate`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingsControllerValidateShareTokenQueryKey = (
  id?: string,
  params?: MeetingsControllerValidateShareTokenParams,
) => {
  return [
    `/api/v1/meetings/${id}/share/validate`,
    ...(params ? [params] : []),
  ] as const;
};

export const getMeetingsControllerValidateShareTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerValidateShareTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getMeetingsControllerValidateShareTokenQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>
  > = ({ signal }) => meetingsControllerValidateShareToken(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingsControllerValidateShareTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>
>;
export type MeetingsControllerValidateShareTokenQueryError = null;

export function useMeetingsControllerValidateShareToken<
  TData = Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerValidateShareTokenParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingsControllerValidateShareToken<
  TData = Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerValidateShareTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
          TError,
          Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingsControllerValidateShareToken<
  TData = Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerValidateShareTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Validate a share token for a meeting
 */

export function useMeetingsControllerValidateShareToken<
  TData = Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
  TError = null,
>(
  id: string,
  params: MeetingsControllerValidateShareTokenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingsControllerValidateShareToken>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingsControllerValidateShareTokenQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get a secure URL for streaming a shared meeting's video using share token
 * @summary Get video streaming URL for shared meeting
 */
export const publicMeetingsControllerGetSharedMeetingStreamingUrl = (
  id: string,
  params: PublicMeetingsControllerGetSharedMeetingStreamingUrlParams,
  signal?: AbortSignal,
) => {
  return customInstance<VideoStreamResponseDto>({
    url: `/api/v1/public/meetings/${id}/streaming-url`,
    method: "GET",
    params,
    signal,
  });
};

export const getPublicMeetingsControllerGetSharedMeetingStreamingUrlQueryKey = (
  id?: string,
  params?: PublicMeetingsControllerGetSharedMeetingStreamingUrlParams,
) => {
  return [
    `/api/v1/public/meetings/${id}/streaming-url`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPublicMeetingsControllerGetSharedMeetingStreamingUrlQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof publicMeetingsControllerGetSharedMeetingStreamingUrl>
    >,
    TError = null,
  >(
    id: string,
    params: PublicMeetingsControllerGetSharedMeetingStreamingUrlParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getPublicMeetingsControllerGetSharedMeetingStreamingUrlQueryKey(
        id,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof publicMeetingsControllerGetSharedMeetingStreamingUrl>
      >
    > = ({ signal }) =>
      publicMeetingsControllerGetSharedMeetingStreamingUrl(id, params, signal);

    return {
      queryKey,
      queryFn,
      enabled: !!id,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof publicMeetingsControllerGetSharedMeetingStreamingUrl>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData> };
  };

export type PublicMeetingsControllerGetSharedMeetingStreamingUrlQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof publicMeetingsControllerGetSharedMeetingStreamingUrl>
    >
  >;
export type PublicMeetingsControllerGetSharedMeetingStreamingUrlQueryError =
  null;

export function usePublicMeetingsControllerGetSharedMeetingStreamingUrl<
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerGetSharedMeetingStreamingUrl>
  >,
  TError = null,
>(
  id: string,
  params: PublicMeetingsControllerGetSharedMeetingStreamingUrlParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePublicMeetingsControllerGetSharedMeetingStreamingUrl<
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerGetSharedMeetingStreamingUrl>
  >,
  TError = null,
>(
  id: string,
  params: PublicMeetingsControllerGetSharedMeetingStreamingUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePublicMeetingsControllerGetSharedMeetingStreamingUrl<
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerGetSharedMeetingStreamingUrl>
  >,
  TError = null,
>(
  id: string,
  params: PublicMeetingsControllerGetSharedMeetingStreamingUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get video streaming URL for shared meeting
 */

export function usePublicMeetingsControllerGetSharedMeetingStreamingUrl<
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerGetSharedMeetingStreamingUrl>
  >,
  TError = null,
>(
  id: string,
  params: PublicMeetingsControllerGetSharedMeetingStreamingUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof publicMeetingsControllerGetSharedMeetingStreamingUrl
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getPublicMeetingsControllerGetSharedMeetingStreamingUrlQueryOptions(
      id,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Stream a meeting's video using a signed token for secure access without full authentication
 * @summary Stream meeting video with signed token
 */
export const publicMeetingsControllerStreamMeetingVideo = (
  id: string,
  params: PublicMeetingsControllerStreamMeetingVideoParams,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/api/v1/public/meetings/${id}/video-stream`,
    method: "GET",
    params,
    signal,
  });
};

export const getPublicMeetingsControllerStreamMeetingVideoQueryKey = (
  id?: string,
  params?: PublicMeetingsControllerStreamMeetingVideoParams,
) => {
  return [
    `/api/v1/public/meetings/${id}/video-stream`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPublicMeetingsControllerStreamMeetingVideoQueryOptions = <
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>
  >,
  TError = null | null,
>(
  id: string,
  params: PublicMeetingsControllerStreamMeetingVideoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPublicMeetingsControllerStreamMeetingVideoQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>
  > = ({ signal }) =>
    publicMeetingsControllerStreamMeetingVideo(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PublicMeetingsControllerStreamMeetingVideoQueryResult = NonNullable<
  Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>
>;
export type PublicMeetingsControllerStreamMeetingVideoQueryError = null | null;

export function usePublicMeetingsControllerStreamMeetingVideo<
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>
  >,
  TError = null | null,
>(
  id: string,
  params: PublicMeetingsControllerStreamMeetingVideoParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>
          >,
          TError,
          Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePublicMeetingsControllerStreamMeetingVideo<
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>
  >,
  TError = null | null,
>(
  id: string,
  params: PublicMeetingsControllerStreamMeetingVideoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>
          >,
          TError,
          Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePublicMeetingsControllerStreamMeetingVideo<
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>
  >,
  TError = null | null,
>(
  id: string,
  params: PublicMeetingsControllerStreamMeetingVideoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Stream meeting video with signed token
 */

export function usePublicMeetingsControllerStreamMeetingVideo<
  TData = Awaited<
    ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>
  >,
  TError = null | null,
>(
  id: string,
  params: PublicMeetingsControllerStreamMeetingVideoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicMeetingsControllerStreamMeetingVideo>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getPublicMeetingsControllerStreamMeetingVideoQueryOptions(
      id,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get all meeting types for the specified organization.
 */
export const meetingTypesControllerFindAll = (
  params: MeetingTypesControllerFindAllParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/meeting-types`,
    method: "GET",
    params,
    signal,
  });
};

export const getMeetingTypesControllerFindAllQueryKey = (
  params?: MeetingTypesControllerFindAllParams,
) => {
  return [`/api/v1/meeting-types`, ...(params ? [params] : [])] as const;
};

export const getMeetingTypesControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
  TError = null,
>(
  params: MeetingTypesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMeetingTypesControllerFindAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof meetingTypesControllerFindAll>>
  > = ({ signal }) => meetingTypesControllerFindAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type MeetingTypesControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof meetingTypesControllerFindAll>>
>;
export type MeetingTypesControllerFindAllQueryError = null;

export function useMeetingTypesControllerFindAll<
  TData = Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
  TError = null,
>(
  params: MeetingTypesControllerFindAllParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof meetingTypesControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useMeetingTypesControllerFindAll<
  TData = Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
  TError = null,
>(
  params: MeetingTypesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof meetingTypesControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useMeetingTypesControllerFindAll<
  TData = Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
  TError = null,
>(
  params: MeetingTypesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all meeting types for the specified organization.
 */

export function useMeetingTypesControllerFindAll<
  TData = Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
  TError = null,
>(
  params: MeetingTypesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof meetingTypesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getMeetingTypesControllerFindAllQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new meeting type and grants access to the user's team. The meeting type will be used to categorize and analyze meetings.
 * @summary Create a new meeting type
 */
export const meetingTypesControllerCreate = (
  createMeetingTypeDto: CreateMeetingTypeDto,
  params: MeetingTypesControllerCreateParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingTypeResponse>({
    url: `/api/v1/meeting-types`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createMeetingTypeDto,
    params,
    signal,
  });
};

export const getMeetingTypesControllerCreateMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingTypesControllerCreate>>,
    TError,
    { data: CreateMeetingTypeDto; params: MeetingTypesControllerCreateParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingTypesControllerCreate>>,
  TError,
  { data: CreateMeetingTypeDto; params: MeetingTypesControllerCreateParams },
  TContext
> => {
  const mutationKey = ["meetingTypesControllerCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingTypesControllerCreate>>,
    { data: CreateMeetingTypeDto; params: MeetingTypesControllerCreateParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return meetingTypesControllerCreate(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingTypesControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingTypesControllerCreate>>
>;
export type MeetingTypesControllerCreateMutationBody = CreateMeetingTypeDto;
export type MeetingTypesControllerCreateMutationError = null | null;

/**
 * @summary Create a new meeting type
 */
export const useMeetingTypesControllerCreate = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingTypesControllerCreate>>,
      TError,
      {
        data: CreateMeetingTypeDto;
        params: MeetingTypesControllerCreateParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingTypesControllerCreate>>,
  TError,
  { data: CreateMeetingTypeDto; params: MeetingTypesControllerCreateParams },
  TContext
> => {
  const mutationOptions =
    getMeetingTypesControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Updates the details of an existing meeting type. Only fields that are provided will be updated.
 * @summary Update an existing meeting type
 */
export const meetingTypesControllerUpdate = (
  id: string,
  updateMeetingTypeDto: UpdateMeetingTypeDto,
  params: MeetingTypesControllerUpdateParams,
) => {
  return customInstance<MeetingTypeResponse>({
    url: `/api/v1/meeting-types/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: updateMeetingTypeDto,
    params,
  });
};

export const getMeetingTypesControllerUpdateMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingTypesControllerUpdate>>,
    TError,
    {
      id: string;
      data: UpdateMeetingTypeDto;
      params: MeetingTypesControllerUpdateParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingTypesControllerUpdate>>,
  TError,
  {
    id: string;
    data: UpdateMeetingTypeDto;
    params: MeetingTypesControllerUpdateParams;
  },
  TContext
> => {
  const mutationKey = ["meetingTypesControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingTypesControllerUpdate>>,
    {
      id: string;
      data: UpdateMeetingTypeDto;
      params: MeetingTypesControllerUpdateParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return meetingTypesControllerUpdate(id, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingTypesControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingTypesControllerUpdate>>
>;
export type MeetingTypesControllerUpdateMutationBody = UpdateMeetingTypeDto;
export type MeetingTypesControllerUpdateMutationError = null | null | null;

/**
 * @summary Update an existing meeting type
 */
export const useMeetingTypesControllerUpdate = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingTypesControllerUpdate>>,
      TError,
      {
        id: string;
        data: UpdateMeetingTypeDto;
        params: MeetingTypesControllerUpdateParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingTypesControllerUpdate>>,
  TError,
  {
    id: string;
    data: UpdateMeetingTypeDto;
    params: MeetingTypesControllerUpdateParams;
  },
  TContext
> => {
  const mutationOptions =
    getMeetingTypesControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes a meeting type by ID. This action cannot be undone.
 * @summary Delete a meeting type
 */
export const meetingTypesControllerRemove = (
  id: string,
  params: MeetingTypesControllerRemoveParams,
) => {
  return customInstance<null>({
    url: `/api/v1/meeting-types/${id}`,
    method: "DELETE",
    params,
  });
};

export const getMeetingTypesControllerRemoveMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingTypesControllerRemove>>,
    TError,
    { id: string; params: MeetingTypesControllerRemoveParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingTypesControllerRemove>>,
  TError,
  { id: string; params: MeetingTypesControllerRemoveParams },
  TContext
> => {
  const mutationKey = ["meetingTypesControllerRemove"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingTypesControllerRemove>>,
    { id: string; params: MeetingTypesControllerRemoveParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return meetingTypesControllerRemove(id, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingTypesControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof meetingTypesControllerRemove>>
>;

export type MeetingTypesControllerRemoveMutationError = null | null;

/**
 * @summary Delete a meeting type
 */
export const useMeetingTypesControllerRemove = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingTypesControllerRemove>>,
      TError,
      { id: string; params: MeetingTypesControllerRemoveParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingTypesControllerRemove>>,
  TError,
  { id: string; params: MeetingTypesControllerRemoveParams },
  TContext
> => {
  const mutationOptions =
    getMeetingTypesControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Uses AI to generate a complete meeting type with metadata structure based on the provided objective.
 * @summary Generate a new meeting type using AI based on an objective.
 */
export const meetingTypesControllerGenerateMeetingType = (
  generateMeetingTypeDto: GenerateMeetingTypeDto,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingTypesControllerGenerateMeetingType201>({
    url: `/api/v1/meeting-types/generate`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: generateMeetingTypeDto,
    signal,
  });
};

export const getMeetingTypesControllerGenerateMeetingTypeMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingTypesControllerGenerateMeetingType>>,
    TError,
    { data: GenerateMeetingTypeDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingTypesControllerGenerateMeetingType>>,
  TError,
  { data: GenerateMeetingTypeDto },
  TContext
> => {
  const mutationKey = ["meetingTypesControllerGenerateMeetingType"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingTypesControllerGenerateMeetingType>>,
    { data: GenerateMeetingTypeDto }
  > = (props) => {
    const { data } = props ?? {};

    return meetingTypesControllerGenerateMeetingType(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingTypesControllerGenerateMeetingTypeMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof meetingTypesControllerGenerateMeetingType>>
  >;
export type MeetingTypesControllerGenerateMeetingTypeMutationBody =
  GenerateMeetingTypeDto;
export type MeetingTypesControllerGenerateMeetingTypeMutationError =
  | null
  | null;

/**
 * @summary Generate a new meeting type using AI based on an objective.
 */
export const useMeetingTypesControllerGenerateMeetingType = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingTypesControllerGenerateMeetingType>>,
      TError,
      { data: GenerateMeetingTypeDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingTypesControllerGenerateMeetingType>>,
  TError,
  { data: GenerateMeetingTypeDto },
  TContext
> => {
  const mutationOptions =
    getMeetingTypesControllerGenerateMeetingTypeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Uses AI to generate analysis topics based on the meeting type name and description.
 * @summary Generate analysis topics for a meeting type using AI based on its description.
 */
export const meetingTypesControllerGenerateAnalysisTopics = (
  generateAnalysisTopicsDto: GenerateAnalysisTopicsDto,
  params: MeetingTypesControllerGenerateAnalysisTopicsParams,
  signal?: AbortSignal,
) => {
  return customInstance<MeetingTypesControllerGenerateAnalysisTopics201>({
    url: `/api/v1/meeting-types/generate-analysis-topics`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: generateAnalysisTopicsDto,
    params,
    signal,
  });
};

export const getMeetingTypesControllerGenerateAnalysisTopicsMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof meetingTypesControllerGenerateAnalysisTopics>>,
    TError,
    {
      data: GenerateAnalysisTopicsDto;
      params: MeetingTypesControllerGenerateAnalysisTopicsParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof meetingTypesControllerGenerateAnalysisTopics>>,
  TError,
  {
    data: GenerateAnalysisTopicsDto;
    params: MeetingTypesControllerGenerateAnalysisTopicsParams;
  },
  TContext
> => {
  const mutationKey = ["meetingTypesControllerGenerateAnalysisTopics"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof meetingTypesControllerGenerateAnalysisTopics>>,
    {
      data: GenerateAnalysisTopicsDto;
      params: MeetingTypesControllerGenerateAnalysisTopicsParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return meetingTypesControllerGenerateAnalysisTopics(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type MeetingTypesControllerGenerateAnalysisTopicsMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof meetingTypesControllerGenerateAnalysisTopics>>
  >;
export type MeetingTypesControllerGenerateAnalysisTopicsMutationBody =
  GenerateAnalysisTopicsDto;
export type MeetingTypesControllerGenerateAnalysisTopicsMutationError =
  | null
  | null;

/**
 * @summary Generate analysis topics for a meeting type using AI based on its description.
 */
export const useMeetingTypesControllerGenerateAnalysisTopics = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof meetingTypesControllerGenerateAnalysisTopics>>,
      TError,
      {
        data: GenerateAnalysisTopicsDto;
        params: MeetingTypesControllerGenerateAnalysisTopicsParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingTypesControllerGenerateAnalysisTopics>>,
  TError,
  {
    data: GenerateAnalysisTopicsDto;
    params: MeetingTypesControllerGenerateAnalysisTopicsParams;
  },
  TContext
> => {
  const mutationOptions =
    getMeetingTypesControllerGenerateAnalysisTopicsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get usage events for an organization
 */
export const usageEventsControllerGetEvents = (
  params: UsageEventsControllerGetEventsParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/usage/events`,
    method: "GET",
    params,
    signal,
  });
};

export const getUsageEventsControllerGetEventsQueryKey = (
  params?: UsageEventsControllerGetEventsParams,
) => {
  return [`/api/v1/usage/events`, ...(params ? [params] : [])] as const;
};

export const getUsageEventsControllerGetEventsQueryOptions = <
  TData = Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
  TError = null,
>(
  params: UsageEventsControllerGetEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsageEventsControllerGetEventsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usageEventsControllerGetEvents>>
  > = ({ signal }) => usageEventsControllerGetEvents(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type UsageEventsControllerGetEventsQueryResult = NonNullable<
  Awaited<ReturnType<typeof usageEventsControllerGetEvents>>
>;
export type UsageEventsControllerGetEventsQueryError = null;

export function useUsageEventsControllerGetEvents<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
  TError = null,
>(
  params: UsageEventsControllerGetEventsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
          TError,
          Awaited<ReturnType<typeof usageEventsControllerGetEvents>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useUsageEventsControllerGetEvents<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
  TError = null,
>(
  params: UsageEventsControllerGetEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
          TError,
          Awaited<ReturnType<typeof usageEventsControllerGetEvents>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useUsageEventsControllerGetEvents<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
  TError = null,
>(
  params: UsageEventsControllerGetEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get usage events for an organization
 */

export function useUsageEventsControllerGetEvents<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
  TError = null,
>(
  params: UsageEventsControllerGetEventsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetEvents>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getUsageEventsControllerGetEventsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get usage summary for an organization
 */
export const usageEventsControllerGetUsageSummary = (
  params: UsageEventsControllerGetUsageSummaryParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/usage/summary`,
    method: "GET",
    params,
    signal,
  });
};

export const getUsageEventsControllerGetUsageSummaryQueryKey = (
  params?: UsageEventsControllerGetUsageSummaryParams,
) => {
  return [`/api/v1/usage/summary`, ...(params ? [params] : [])] as const;
};

export const getUsageEventsControllerGetUsageSummaryQueryOptions = <
  TData = Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
  TError = null,
>(
  params: UsageEventsControllerGetUsageSummaryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getUsageEventsControllerGetUsageSummaryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>
  > = ({ signal }) => usageEventsControllerGetUsageSummary(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type UsageEventsControllerGetUsageSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>
>;
export type UsageEventsControllerGetUsageSummaryQueryError = null;

export function useUsageEventsControllerGetUsageSummary<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
  TError = null,
>(
  params: UsageEventsControllerGetUsageSummaryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
          TError,
          Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useUsageEventsControllerGetUsageSummary<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
  TError = null,
>(
  params: UsageEventsControllerGetUsageSummaryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
          TError,
          Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useUsageEventsControllerGetUsageSummary<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
  TError = null,
>(
  params: UsageEventsControllerGetUsageSummaryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get usage summary for an organization
 */

export function useUsageEventsControllerGetUsageSummary<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
  TError = null,
>(
  params: UsageEventsControllerGetUsageSummaryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetUsageSummary>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getUsageEventsControllerGetUsageSummaryQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get current usage for a specific metric
 */
export const usageEventsControllerGetCurrentUsage = (
  metricType: string,
  params: UsageEventsControllerGetCurrentUsageParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/usage/metric/${metricType}`,
    method: "GET",
    params,
    signal,
  });
};

export const getUsageEventsControllerGetCurrentUsageQueryKey = (
  metricType?: string,
  params?: UsageEventsControllerGetCurrentUsageParams,
) => {
  return [
    `/api/v1/usage/metric/${metricType}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getUsageEventsControllerGetCurrentUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
  TError = null,
>(
  metricType: string,
  params: UsageEventsControllerGetCurrentUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getUsageEventsControllerGetCurrentUsageQueryKey(metricType, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>
  > = ({ signal }) =>
    usageEventsControllerGetCurrentUsage(metricType, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!metricType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type UsageEventsControllerGetCurrentUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>
>;
export type UsageEventsControllerGetCurrentUsageQueryError = null;

export function useUsageEventsControllerGetCurrentUsage<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
  TError = null,
>(
  metricType: string,
  params: UsageEventsControllerGetCurrentUsageParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
          TError,
          Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useUsageEventsControllerGetCurrentUsage<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
  TError = null,
>(
  metricType: string,
  params: UsageEventsControllerGetCurrentUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
          TError,
          Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useUsageEventsControllerGetCurrentUsage<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
  TError = null,
>(
  metricType: string,
  params: UsageEventsControllerGetCurrentUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get current usage for a specific metric
 */

export function useUsageEventsControllerGetCurrentUsage<
  TData = Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
  TError = null,
>(
  metricType: string,
  params: UsageEventsControllerGetCurrentUsageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof usageEventsControllerGetCurrentUsage>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getUsageEventsControllerGetCurrentUsageQueryOptions(
    metricType,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Manually reset the monthly minutes usage counter for a specific organization. This is typically used for admin overrides or plan changes.
 * @summary Reset monthly minutes usage for an organization (Admin only)
 */
export const usageEventsControllerResetMonthlyMinutesUsage = (
  params: UsageEventsControllerResetMonthlyMinutesUsageParams,
  signal?: AbortSignal,
) => {
  return customInstance<MonthlyMinutesResetDto>({
    url: `/api/v1/usage/monthly-minutes/reset`,
    method: "POST",
    params,
    signal,
  });
};

export const getUsageEventsControllerResetMonthlyMinutesUsageMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usageEventsControllerResetMonthlyMinutesUsage>>,
    TError,
    { params: UsageEventsControllerResetMonthlyMinutesUsageParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usageEventsControllerResetMonthlyMinutesUsage>>,
  TError,
  { params: UsageEventsControllerResetMonthlyMinutesUsageParams },
  TContext
> => {
  const mutationKey = ["usageEventsControllerResetMonthlyMinutesUsage"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usageEventsControllerResetMonthlyMinutesUsage>>,
    { params: UsageEventsControllerResetMonthlyMinutesUsageParams }
  > = (props) => {
    const { params } = props ?? {};

    return usageEventsControllerResetMonthlyMinutesUsage(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsageEventsControllerResetMonthlyMinutesUsageMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof usageEventsControllerResetMonthlyMinutesUsage>>
  >;

export type UsageEventsControllerResetMonthlyMinutesUsageMutationError =
  | null
  | null;

/**
 * @summary Reset monthly minutes usage for an organization (Admin only)
 */
export const useUsageEventsControllerResetMonthlyMinutesUsage = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof usageEventsControllerResetMonthlyMinutesUsage>>,
      TError,
      { params: UsageEventsControllerResetMonthlyMinutesUsageParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof usageEventsControllerResetMonthlyMinutesUsage>>,
  TError,
  { params: UsageEventsControllerResetMonthlyMinutesUsageParams },
  TContext
> => {
  const mutationOptions =
    getUsageEventsControllerResetMonthlyMinutesUsageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve the history of monthly minutes resets for audit purposes.
 * @summary Get monthly minutes reset history for an organization
 */
export const usageEventsControllerGetMonthlyMinutesResetHistory = (
  params: UsageEventsControllerGetMonthlyMinutesResetHistoryParams,
  signal?: AbortSignal,
) => {
  return customInstance<MonthlyMinutesResetHistoryDto>({
    url: `/api/v1/usage/monthly-minutes/reset-history`,
    method: "GET",
    params,
    signal,
  });
};

export const getUsageEventsControllerGetMonthlyMinutesResetHistoryQueryKey = (
  params?: UsageEventsControllerGetMonthlyMinutesResetHistoryParams,
) => {
  return [
    `/api/v1/usage/monthly-minutes/reset-history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getUsageEventsControllerGetMonthlyMinutesResetHistoryQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
    >,
    TError = null,
  >(
    params: UsageEventsControllerGetMonthlyMinutesResetHistoryParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof usageEventsControllerGetMonthlyMinutesResetHistory
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getUsageEventsControllerGetMonthlyMinutesResetHistoryQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
      >
    > = ({ signal }) =>
      usageEventsControllerGetMonthlyMinutesResetHistory(params, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData> };
  };

export type UsageEventsControllerGetMonthlyMinutesResetHistoryQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
    >
  >;
export type UsageEventsControllerGetMonthlyMinutesResetHistoryQueryError = null;

export function useUsageEventsControllerGetMonthlyMinutesResetHistory<
  TData = Awaited<
    ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
  >,
  TError = null,
>(
  params: UsageEventsControllerGetMonthlyMinutesResetHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof usageEventsControllerGetMonthlyMinutesResetHistory
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof usageEventsControllerGetMonthlyMinutesResetHistory
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useUsageEventsControllerGetMonthlyMinutesResetHistory<
  TData = Awaited<
    ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
  >,
  TError = null,
>(
  params: UsageEventsControllerGetMonthlyMinutesResetHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof usageEventsControllerGetMonthlyMinutesResetHistory
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof usageEventsControllerGetMonthlyMinutesResetHistory
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useUsageEventsControllerGetMonthlyMinutesResetHistory<
  TData = Awaited<
    ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
  >,
  TError = null,
>(
  params: UsageEventsControllerGetMonthlyMinutesResetHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get monthly minutes reset history for an organization
 */

export function useUsageEventsControllerGetMonthlyMinutesResetHistory<
  TData = Awaited<
    ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
  >,
  TError = null,
>(
  params: UsageEventsControllerGetMonthlyMinutesResetHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof usageEventsControllerGetMonthlyMinutesResetHistory>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getUsageEventsControllerGetMonthlyMinutesResetHistoryQueryOptions(
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Send message to n8n webhook for AI processing
 */
export const n8nControllerSendMessage = (signal?: AbortSignal) => {
  return customInstance<null>({
    url: `/api/v1/n8n/send-message`,
    method: "POST",
    signal,
  });
};

export const getN8nControllerSendMessageMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof n8nControllerSendMessage>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof n8nControllerSendMessage>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["n8nControllerSendMessage"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof n8nControllerSendMessage>>,
    void
  > = () => {
    return n8nControllerSendMessage();
  };

  return { mutationFn, ...mutationOptions };
};

export type N8nControllerSendMessageMutationResult = NonNullable<
  Awaited<ReturnType<typeof n8nControllerSendMessage>>
>;

export type N8nControllerSendMessageMutationError = unknown;

/**
 * @summary Send message to n8n webhook for AI processing
 */
export const useN8nControllerSendMessage = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof n8nControllerSendMessage>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof n8nControllerSendMessage>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getN8nControllerSendMessageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create a new AI conversation history
 */
export const aiConversationHistoriesControllerCreate = (
  createAiConversationHistoriesDto: CreateAiConversationHistoriesDto,
  params: AiConversationHistoriesControllerCreateParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/ai-conversation-histories`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createAiConversationHistoriesDto,
    params,
    signal,
  });
};

export const getAiConversationHistoriesControllerCreateMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerCreate>>,
    TError,
    {
      data: CreateAiConversationHistoriesDto;
      params: AiConversationHistoriesControllerCreateParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerCreate>>,
  TError,
  {
    data: CreateAiConversationHistoriesDto;
    params: AiConversationHistoriesControllerCreateParams;
  },
  TContext
> => {
  const mutationKey = ["aiConversationHistoriesControllerCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerCreate>>,
    {
      data: CreateAiConversationHistoriesDto;
      params: AiConversationHistoriesControllerCreateParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return aiConversationHistoriesControllerCreate(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiConversationHistoriesControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerCreate>>
>;
export type AiConversationHistoriesControllerCreateMutationBody =
  CreateAiConversationHistoriesDto;
export type AiConversationHistoriesControllerCreateMutationError = null;

/**
 * @summary Create a new AI conversation history
 */
export const useAiConversationHistoriesControllerCreate = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiConversationHistoriesControllerCreate>>,
      TError,
      {
        data: CreateAiConversationHistoriesDto;
        params: AiConversationHistoriesControllerCreateParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerCreate>>,
  TError,
  {
    data: CreateAiConversationHistoriesDto;
    params: AiConversationHistoriesControllerCreateParams;
  },
  TContext
> => {
  const mutationOptions =
    getAiConversationHistoriesControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all AI conversation histories
 */
export const aiConversationHistoriesControllerFindAll = (
  params?: AiConversationHistoriesControllerFindAllParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/ai-conversation-histories`,
    method: "GET",
    params,
    signal,
  });
};

export const getAiConversationHistoriesControllerFindAllQueryKey = (
  params?: AiConversationHistoriesControllerFindAllParams,
) => {
  return [
    `/api/v1/ai-conversation-histories`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAiConversationHistoriesControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
  TError = unknown,
>(
  params?: AiConversationHistoriesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiConversationHistoriesControllerFindAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>
  > = ({ signal }) => aiConversationHistoriesControllerFindAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AiConversationHistoriesControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>
>;
export type AiConversationHistoriesControllerFindAllQueryError = unknown;

export function useAiConversationHistoriesControllerFindAll<
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
  TError = unknown,
>(
  params: undefined | AiConversationHistoriesControllerFindAllParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useAiConversationHistoriesControllerFindAll<
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
  TError = unknown,
>(
  params?: AiConversationHistoriesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAiConversationHistoriesControllerFindAll<
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
  TError = unknown,
>(
  params?: AiConversationHistoriesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all AI conversation histories
 */

export function useAiConversationHistoriesControllerFindAll<
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
  TError = unknown,
>(
  params?: AiConversationHistoriesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAiConversationHistoriesControllerFindAllQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get conversation history by session ID
 */
export const aiConversationHistoriesControllerFindBySessionId = (
  sessionId: string,
  params: AiConversationHistoriesControllerFindBySessionIdParams,
  signal?: AbortSignal,
) => {
  return customInstance<AiConversationHistoriesResponseDto[]>({
    url: `/api/v1/ai-conversation-histories/session/${sessionId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getAiConversationHistoriesControllerFindBySessionIdQueryKey = (
  sessionId?: string,
  params?: AiConversationHistoriesControllerFindBySessionIdParams,
) => {
  return [
    `/api/v1/ai-conversation-histories/session/${sessionId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAiConversationHistoriesControllerFindBySessionIdQueryOptions = <
  TData = Awaited<
    ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
  >,
  TError = null | null,
>(
  sessionId: string,
  params: AiConversationHistoriesControllerFindBySessionIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiConversationHistoriesControllerFindBySessionIdQueryKey(
      sessionId,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>>
  > = ({ signal }) =>
    aiConversationHistoriesControllerFindBySessionId(sessionId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!sessionId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<
      ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
    >,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AiConversationHistoriesControllerFindBySessionIdQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>>
  >;
export type AiConversationHistoriesControllerFindBySessionIdQueryError =
  | null
  | null;

export function useAiConversationHistoriesControllerFindBySessionId<
  TData = Awaited<
    ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
  >,
  TError = null | null,
>(
  sessionId: string,
  params: AiConversationHistoriesControllerFindBySessionIdParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
          >,
          TError,
          Awaited<
            ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useAiConversationHistoriesControllerFindBySessionId<
  TData = Awaited<
    ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
  >,
  TError = null | null,
>(
  sessionId: string,
  params: AiConversationHistoriesControllerFindBySessionIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
          >,
          TError,
          Awaited<
            ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAiConversationHistoriesControllerFindBySessionId<
  TData = Awaited<
    ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
  >,
  TError = null | null,
>(
  sessionId: string,
  params: AiConversationHistoriesControllerFindBySessionIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get conversation history by session ID
 */

export function useAiConversationHistoriesControllerFindBySessionId<
  TData = Awaited<
    ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
  >,
  TError = null | null,
>(
  sessionId: string,
  params: AiConversationHistoriesControllerFindBySessionIdParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof aiConversationHistoriesControllerFindBySessionId>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getAiConversationHistoriesControllerFindBySessionIdQueryOptions(
      sessionId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get an AI conversation history by ID
 */
export const aiConversationHistoriesControllerFindOne = (
  id: string,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/ai-conversation-histories/${id}`,
    method: "GET",
    signal,
  });
};

export const getAiConversationHistoriesControllerFindOneQueryKey = (
  id?: string,
) => {
  return [`/api/v1/ai-conversation-histories/${id}`] as const;
};

export const getAiConversationHistoriesControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiConversationHistoriesControllerFindOneQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>
  > = ({ signal }) => aiConversationHistoriesControllerFindOne(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AiConversationHistoriesControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>
>;
export type AiConversationHistoriesControllerFindOneQueryError = unknown;

export function useAiConversationHistoriesControllerFindOne<
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useAiConversationHistoriesControllerFindOne<
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAiConversationHistoriesControllerFindOne<
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get an AI conversation history by ID
 */

export function useAiConversationHistoriesControllerFindOne<
  TData = Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationHistoriesControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAiConversationHistoriesControllerFindOneQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update an AI conversation history
 */
export const aiConversationHistoriesControllerUpdate = (
  id: string,
  updateAiConversationHistoriesDto: UpdateAiConversationHistoriesDto,
) => {
  return customInstance<null>({
    url: `/api/v1/ai-conversation-histories/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateAiConversationHistoriesDto,
  });
};

export const getAiConversationHistoriesControllerUpdateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerUpdate>>,
    TError,
    { id: string; data: UpdateAiConversationHistoriesDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerUpdate>>,
  TError,
  { id: string; data: UpdateAiConversationHistoriesDto },
  TContext
> => {
  const mutationKey = ["aiConversationHistoriesControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerUpdate>>,
    { id: string; data: UpdateAiConversationHistoriesDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return aiConversationHistoriesControllerUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiConversationHistoriesControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerUpdate>>
>;
export type AiConversationHistoriesControllerUpdateMutationBody =
  UpdateAiConversationHistoriesDto;
export type AiConversationHistoriesControllerUpdateMutationError = unknown;

/**
 * @summary Update an AI conversation history
 */
export const useAiConversationHistoriesControllerUpdate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiConversationHistoriesControllerUpdate>>,
      TError,
      { id: string; data: UpdateAiConversationHistoriesDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerUpdate>>,
  TError,
  { id: string; data: UpdateAiConversationHistoriesDto },
  TContext
> => {
  const mutationOptions =
    getAiConversationHistoriesControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete an AI conversation history
 */
export const aiConversationHistoriesControllerRemove = (id: string) => {
  return customInstance<null>({
    url: `/api/v1/ai-conversation-histories/${id}`,
    method: "DELETE",
  });
};

export const getAiConversationHistoriesControllerRemoveMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerRemove>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["aiConversationHistoriesControllerRemove"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiConversationHistoriesControllerRemove>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return aiConversationHistoriesControllerRemove(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiConversationHistoriesControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerRemove>>
>;

export type AiConversationHistoriesControllerRemoveMutationError = unknown;

/**
 * @summary Delete an AI conversation history
 */
export const useAiConversationHistoriesControllerRemove = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiConversationHistoriesControllerRemove>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiConversationHistoriesControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getAiConversationHistoriesControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Creates a new conversation session with the provided title in the specified organization
 * @summary Create a new AI conversation session
 */
export const aiConversationSessionsControllerCreate = (
  createAiConversationSessionsDto: CreateAiConversationSessionsDto,
  params: AiConversationSessionsControllerCreateParams,
  signal?: AbortSignal,
) => {
  return customInstance<CreateAiConversationSessionsDto>({
    url: `/api/v1/ai-conversation-sessions/new-session`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createAiConversationSessionsDto,
    params,
    signal,
  });
};

export const getAiConversationSessionsControllerCreateMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiConversationSessionsControllerCreate>>,
    TError,
    {
      data: CreateAiConversationSessionsDto;
      params: AiConversationSessionsControllerCreateParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiConversationSessionsControllerCreate>>,
  TError,
  {
    data: CreateAiConversationSessionsDto;
    params: AiConversationSessionsControllerCreateParams;
  },
  TContext
> => {
  const mutationKey = ["aiConversationSessionsControllerCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiConversationSessionsControllerCreate>>,
    {
      data: CreateAiConversationSessionsDto;
      params: AiConversationSessionsControllerCreateParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return aiConversationSessionsControllerCreate(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiConversationSessionsControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationSessionsControllerCreate>>
>;
export type AiConversationSessionsControllerCreateMutationBody =
  CreateAiConversationSessionsDto;
export type AiConversationSessionsControllerCreateMutationError = null | null;

/**
 * @summary Create a new AI conversation session
 */
export const useAiConversationSessionsControllerCreate = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiConversationSessionsControllerCreate>>,
      TError,
      {
        data: CreateAiConversationSessionsDto;
        params: AiConversationSessionsControllerCreateParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiConversationSessionsControllerCreate>>,
  TError,
  {
    data: CreateAiConversationSessionsDto;
    params: AiConversationSessionsControllerCreateParams;
  },
  TContext
> => {
  const mutationOptions =
    getAiConversationSessionsControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves all conversation sessions in the specified organization for the authenticated user only
 * @summary Get all AI conversation sessions
 */
export const aiConversationSessionsControllerFindAll = (
  params: AiConversationSessionsControllerFindAllParams,
  signal?: AbortSignal,
) => {
  return customInstance<AiConversationSessionResponseDto[]>({
    url: `/api/v1/ai-conversation-sessions`,
    method: "GET",
    params,
    signal,
  });
};

export const getAiConversationSessionsControllerFindAllQueryKey = (
  params?: AiConversationSessionsControllerFindAllParams,
) => {
  return [
    `/api/v1/ai-conversation-sessions`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAiConversationSessionsControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
  TError = null,
>(
  params: AiConversationSessionsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiConversationSessionsControllerFindAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>
  > = ({ signal }) => aiConversationSessionsControllerFindAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AiConversationSessionsControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>
>;
export type AiConversationSessionsControllerFindAllQueryError = null;

export function useAiConversationSessionsControllerFindAll<
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
  TError = null,
>(
  params: AiConversationSessionsControllerFindAllParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useAiConversationSessionsControllerFindAll<
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
  TError = null,
>(
  params: AiConversationSessionsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAiConversationSessionsControllerFindAll<
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
  TError = null,
>(
  params: AiConversationSessionsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all AI conversation sessions
 */

export function useAiConversationSessionsControllerFindAll<
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
  TError = null,
>(
  params: AiConversationSessionsControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAiConversationSessionsControllerFindAllQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a specific conversation session by its ID
 * @summary Get a session by ID
 */
export const aiConversationSessionsControllerFindOne = (
  id: string,
  params: AiConversationSessionsControllerFindOneParams,
  signal?: AbortSignal,
) => {
  return customInstance<CreateAiConversationSessionsDto>({
    url: `/api/v1/ai-conversation-sessions/${id}`,
    method: "GET",
    params,
    signal,
  });
};

export const getAiConversationSessionsControllerFindOneQueryKey = (
  id?: string,
  params?: AiConversationSessionsControllerFindOneParams,
) => {
  return [
    `/api/v1/ai-conversation-sessions/${id}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAiConversationSessionsControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: AiConversationSessionsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAiConversationSessionsControllerFindOneQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>
  > = ({ signal }) =>
    aiConversationSessionsControllerFindOne(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type AiConversationSessionsControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>
>;
export type AiConversationSessionsControllerFindOneQueryError = null | null;

export function useAiConversationSessionsControllerFindOne<
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: AiConversationSessionsControllerFindOneParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useAiConversationSessionsControllerFindOne<
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: AiConversationSessionsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useAiConversationSessionsControllerFindOne<
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: AiConversationSessionsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get a session by ID
 */

export function useAiConversationSessionsControllerFindOne<
  TData = Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: AiConversationSessionsControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof aiConversationSessionsControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getAiConversationSessionsControllerFindOneQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates an existing conversation session with new data
 * @summary Update a session
 */
export const aiConversationSessionsControllerUpdate = (
  id: string,
  updateAiConversationSessionsDto: UpdateAiConversationSessionsDto,
  params: AiConversationSessionsControllerUpdateParams,
) => {
  return customInstance<UpdateAiConversationSessionsDto>({
    url: `/api/v1/ai-conversation-sessions/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateAiConversationSessionsDto,
    params,
  });
};

export const getAiConversationSessionsControllerUpdateMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiConversationSessionsControllerUpdate>>,
    TError,
    {
      id: string;
      data: UpdateAiConversationSessionsDto;
      params: AiConversationSessionsControllerUpdateParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiConversationSessionsControllerUpdate>>,
  TError,
  {
    id: string;
    data: UpdateAiConversationSessionsDto;
    params: AiConversationSessionsControllerUpdateParams;
  },
  TContext
> => {
  const mutationKey = ["aiConversationSessionsControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiConversationSessionsControllerUpdate>>,
    {
      id: string;
      data: UpdateAiConversationSessionsDto;
      params: AiConversationSessionsControllerUpdateParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return aiConversationSessionsControllerUpdate(id, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiConversationSessionsControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationSessionsControllerUpdate>>
>;
export type AiConversationSessionsControllerUpdateMutationBody =
  UpdateAiConversationSessionsDto;
export type AiConversationSessionsControllerUpdateMutationError = null | null;

/**
 * @summary Update a session
 */
export const useAiConversationSessionsControllerUpdate = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiConversationSessionsControllerUpdate>>,
      TError,
      {
        id: string;
        data: UpdateAiConversationSessionsDto;
        params: AiConversationSessionsControllerUpdateParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiConversationSessionsControllerUpdate>>,
  TError,
  {
    id: string;
    data: UpdateAiConversationSessionsDto;
    params: AiConversationSessionsControllerUpdateParams;
  },
  TContext
> => {
  const mutationOptions =
    getAiConversationSessionsControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes a conversation session and its associated history
 * @summary Delete a session
 */
export const aiConversationSessionsControllerRemove = (
  id: string,
  params: AiConversationSessionsControllerRemoveParams,
) => {
  return customInstance<AiConversationSessionsControllerRemove200>({
    url: `/api/v1/ai-conversation-sessions/${id}`,
    method: "DELETE",
    params,
  });
};

export const getAiConversationSessionsControllerRemoveMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof aiConversationSessionsControllerRemove>>,
    TError,
    { id: string; params: AiConversationSessionsControllerRemoveParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof aiConversationSessionsControllerRemove>>,
  TError,
  { id: string; params: AiConversationSessionsControllerRemoveParams },
  TContext
> => {
  const mutationKey = ["aiConversationSessionsControllerRemove"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof aiConversationSessionsControllerRemove>>,
    { id: string; params: AiConversationSessionsControllerRemoveParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return aiConversationSessionsControllerRemove(id, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AiConversationSessionsControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof aiConversationSessionsControllerRemove>>
>;

export type AiConversationSessionsControllerRemoveMutationError = null | null;

/**
 * @summary Delete a session
 */
export const useAiConversationSessionsControllerRemove = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof aiConversationSessionsControllerRemove>>,
      TError,
      { id: string; params: AiConversationSessionsControllerRemoveParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof aiConversationSessionsControllerRemove>>,
  TError,
  { id: string; params: AiConversationSessionsControllerRemoveParams },
  TContext
> => {
  const mutationOptions =
    getAiConversationSessionsControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Creates a new report type with specified schedule and configuration. The report can be scheduled to run weekly, monthly, or quarterly.
 * @summary Create a new report type
 */
export const reportTypesControllerCreate = (
  createReportTypesDto: CreateReportTypesDto,
  params: ReportTypesControllerCreateParams,
  signal?: AbortSignal,
) => {
  return customInstance<ReportTypeResponseDto>({
    url: `/api/v1/report-types`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createReportTypesDto,
    params,
    signal,
  });
};

export const getReportTypesControllerCreateMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportTypesControllerCreate>>,
    TError,
    { data: CreateReportTypesDto; params: ReportTypesControllerCreateParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportTypesControllerCreate>>,
  TError,
  { data: CreateReportTypesDto; params: ReportTypesControllerCreateParams },
  TContext
> => {
  const mutationKey = ["reportTypesControllerCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportTypesControllerCreate>>,
    { data: CreateReportTypesDto; params: ReportTypesControllerCreateParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return reportTypesControllerCreate(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportTypesControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportTypesControllerCreate>>
>;
export type ReportTypesControllerCreateMutationBody = CreateReportTypesDto;
export type ReportTypesControllerCreateMutationError = null | null;

/**
 * @summary Create a new report type
 */
export const useReportTypesControllerCreate = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reportTypesControllerCreate>>,
      TError,
      { data: CreateReportTypesDto; params: ReportTypesControllerCreateParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reportTypesControllerCreate>>,
  TError,
  { data: CreateReportTypesDto; params: ReportTypesControllerCreateParams },
  TContext
> => {
  const mutationOptions =
    getReportTypesControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all report types with permissions
 */
export const reportTypesControllerFindAll = (
  params: ReportTypesControllerFindAllParams,
  signal?: AbortSignal,
) => {
  return customInstance<ReportTypeResponseDto[]>({
    url: `/api/v1/report-types`,
    method: "GET",
    params,
    signal,
  });
};

export const getReportTypesControllerFindAllQueryKey = (
  params?: ReportTypesControllerFindAllParams,
) => {
  return [`/api/v1/report-types`, ...(params ? [params] : [])] as const;
};

export const getReportTypesControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
  TError = null,
>(
  params: ReportTypesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getReportTypesControllerFindAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportTypesControllerFindAll>>
  > = ({ signal }) => reportTypesControllerFindAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ReportTypesControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportTypesControllerFindAll>>
>;
export type ReportTypesControllerFindAllQueryError = null;

export function useReportTypesControllerFindAll<
  TData = Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
  TError = null,
>(
  params: ReportTypesControllerFindAllParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof reportTypesControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useReportTypesControllerFindAll<
  TData = Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
  TError = null,
>(
  params: ReportTypesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof reportTypesControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useReportTypesControllerFindAll<
  TData = Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
  TError = null,
>(
  params: ReportTypesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get all report types with permissions
 */

export function useReportTypesControllerFindAll<
  TData = Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
  TError = null,
>(
  params: ReportTypesControllerFindAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getReportTypesControllerFindAllQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a report type by id
 */
export const reportTypesControllerFindOne = (
  id: string,
  params: ReportTypesControllerFindOneParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/report-types/${id}`,
    method: "GET",
    params,
    signal,
  });
};

export const getReportTypesControllerFindOneQueryKey = (
  id?: string,
  params?: ReportTypesControllerFindOneParams,
) => {
  return [`/api/v1/report-types/${id}`, ...(params ? [params] : [])] as const;
};

export const getReportTypesControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: ReportTypesControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getReportTypesControllerFindOneQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof reportTypesControllerFindOne>>
  > = ({ signal }) => reportTypesControllerFindOne(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ReportTypesControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof reportTypesControllerFindOne>>
>;
export type ReportTypesControllerFindOneQueryError = null | null;

export function useReportTypesControllerFindOne<
  TData = Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: ReportTypesControllerFindOneParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof reportTypesControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useReportTypesControllerFindOne<
  TData = Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: ReportTypesControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof reportTypesControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useReportTypesControllerFindOne<
  TData = Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: ReportTypesControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get a report type by id
 */

export function useReportTypesControllerFindOne<
  TData = Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
  TError = null | null,
>(
  id: string,
  params: ReportTypesControllerFindOneParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof reportTypesControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getReportTypesControllerFindOneQueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates an existing report type. Only fields that are provided will be updated. The report schedule can be modified to change when the report runs.
 * @summary Update a report type
 */
export const reportTypesControllerUpdate = (
  id: string,
  updateReportTypesDto: UpdateReportTypesDto,
  params: ReportTypesControllerUpdateParams,
) => {
  return customInstance<ReportTypeResponseDto>({
    url: `/api/v1/report-types/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateReportTypesDto,
    params,
  });
};

export const getReportTypesControllerUpdateMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportTypesControllerUpdate>>,
    TError,
    {
      id: string;
      data: UpdateReportTypesDto;
      params: ReportTypesControllerUpdateParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportTypesControllerUpdate>>,
  TError,
  {
    id: string;
    data: UpdateReportTypesDto;
    params: ReportTypesControllerUpdateParams;
  },
  TContext
> => {
  const mutationKey = ["reportTypesControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportTypesControllerUpdate>>,
    {
      id: string;
      data: UpdateReportTypesDto;
      params: ReportTypesControllerUpdateParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return reportTypesControllerUpdate(id, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportTypesControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportTypesControllerUpdate>>
>;
export type ReportTypesControllerUpdateMutationBody = UpdateReportTypesDto;
export type ReportTypesControllerUpdateMutationError = null | null | null;

/**
 * @summary Update a report type
 */
export const useReportTypesControllerUpdate = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reportTypesControllerUpdate>>,
      TError,
      {
        id: string;
        data: UpdateReportTypesDto;
        params: ReportTypesControllerUpdateParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reportTypesControllerUpdate>>,
  TError,
  {
    id: string;
    data: UpdateReportTypesDto;
    params: ReportTypesControllerUpdateParams;
  },
  TContext
> => {
  const mutationOptions =
    getReportTypesControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a report type
 */
export const reportTypesControllerRemove = (
  id: string,
  params: ReportTypesControllerRemoveParams,
) => {
  return customInstance<null>({
    url: `/api/v1/report-types/${id}`,
    method: "DELETE",
    params,
  });
};

export const getReportTypesControllerRemoveMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportTypesControllerRemove>>,
    TError,
    { id: string; params: ReportTypesControllerRemoveParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportTypesControllerRemove>>,
  TError,
  { id: string; params: ReportTypesControllerRemoveParams },
  TContext
> => {
  const mutationKey = ["reportTypesControllerRemove"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportTypesControllerRemove>>,
    { id: string; params: ReportTypesControllerRemoveParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return reportTypesControllerRemove(id, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportTypesControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportTypesControllerRemove>>
>;

export type ReportTypesControllerRemoveMutationError = null | null;

/**
 * @summary Delete a report type
 */
export const useReportTypesControllerRemove = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reportTypesControllerRemove>>,
      TError,
      { id: string; params: ReportTypesControllerRemoveParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reportTypesControllerRemove>>,
  TError,
  { id: string; params: ReportTypesControllerRemoveParams },
  TContext
> => {
  const mutationOptions =
    getReportTypesControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create webhook
 */
export const webhooksControllerCreate = (
  organizationId: string,
  createWebhookDto: CreateWebhookDto,
  signal?: AbortSignal,
) => {
  return customInstance<WebhookResponseDto>({
    url: `/api/v1/organizations/${organizationId}/webhooks`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createWebhookDto,
    signal,
  });
};

export const getWebhooksControllerCreateMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksControllerCreate>>,
    TError,
    { organizationId: string; data: CreateWebhookDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksControllerCreate>>,
  TError,
  { organizationId: string; data: CreateWebhookDto },
  TContext
> => {
  const mutationKey = ["webhooksControllerCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksControllerCreate>>,
    { organizationId: string; data: CreateWebhookDto }
  > = (props) => {
    const { organizationId, data } = props ?? {};

    return webhooksControllerCreate(organizationId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksControllerCreate>>
>;
export type WebhooksControllerCreateMutationBody = CreateWebhookDto;
export type WebhooksControllerCreateMutationError = null | null;

/**
 * @summary Create webhook
 */
export const useWebhooksControllerCreate = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof webhooksControllerCreate>>,
      TError,
      { organizationId: string; data: CreateWebhookDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof webhooksControllerCreate>>,
  TError,
  { organizationId: string; data: CreateWebhookDto },
  TContext
> => {
  const mutationOptions = getWebhooksControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get organization webhook
 */
export const webhooksControllerFindOne = (
  organizationId: string,
  signal?: AbortSignal,
) => {
  return customInstance<WebhookResponseDto>({
    url: `/api/v1/organizations/${organizationId}/webhooks`,
    method: "GET",
    signal,
  });
};

export const getWebhooksControllerFindOneQueryKey = (
  organizationId?: string,
) => {
  return [`/api/v1/organizations/${organizationId}/webhooks`] as const;
};

export const getWebhooksControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof webhooksControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getWebhooksControllerFindOneQueryKey(organizationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof webhooksControllerFindOne>>
  > = ({ signal }) => webhooksControllerFindOne(organizationId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof webhooksControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type WebhooksControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof webhooksControllerFindOne>>
>;
export type WebhooksControllerFindOneQueryError = null;

export function useWebhooksControllerFindOne<
  TData = Awaited<ReturnType<typeof webhooksControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof webhooksControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useWebhooksControllerFindOne<
  TData = Awaited<ReturnType<typeof webhooksControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof webhooksControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof webhooksControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useWebhooksControllerFindOne<
  TData = Awaited<ReturnType<typeof webhooksControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get organization webhook
 */

export function useWebhooksControllerFindOne<
  TData = Awaited<ReturnType<typeof webhooksControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof webhooksControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getWebhooksControllerFindOneQueryOptions(
    organizationId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update webhook
 */
export const webhooksControllerUpdate = (
  organizationId: string,
  id: string,
  updateWebhookDto: UpdateWebhookDto,
) => {
  return customInstance<WebhookResponseDto>({
    url: `/api/v1/organizations/${organizationId}/webhooks/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateWebhookDto,
  });
};

export const getWebhooksControllerUpdateMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksControllerUpdate>>,
    TError,
    { organizationId: string; id: string; data: UpdateWebhookDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksControllerUpdate>>,
  TError,
  { organizationId: string; id: string; data: UpdateWebhookDto },
  TContext
> => {
  const mutationKey = ["webhooksControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksControllerUpdate>>,
    { organizationId: string; id: string; data: UpdateWebhookDto }
  > = (props) => {
    const { organizationId, id, data } = props ?? {};

    return webhooksControllerUpdate(organizationId, id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksControllerUpdate>>
>;
export type WebhooksControllerUpdateMutationBody = UpdateWebhookDto;
export type WebhooksControllerUpdateMutationError = null;

/**
 * @summary Update webhook
 */
export const useWebhooksControllerUpdate = <TError = null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof webhooksControllerUpdate>>,
      TError,
      { organizationId: string; id: string; data: UpdateWebhookDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof webhooksControllerUpdate>>,
  TError,
  { organizationId: string; id: string; data: UpdateWebhookDto },
  TContext
> => {
  const mutationOptions = getWebhooksControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete webhook
 */
export const webhooksControllerDelete = (
  organizationId: string,
  id: string,
) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${organizationId}/webhooks/${id}`,
    method: "DELETE",
  });
};

export const getWebhooksControllerDeleteMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksControllerDelete>>,
    TError,
    { organizationId: string; id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksControllerDelete>>,
  TError,
  { organizationId: string; id: string },
  TContext
> => {
  const mutationKey = ["webhooksControllerDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksControllerDelete>>,
    { organizationId: string; id: string }
  > = (props) => {
    const { organizationId, id } = props ?? {};

    return webhooksControllerDelete(organizationId, id);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksControllerDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksControllerDelete>>
>;

export type WebhooksControllerDeleteMutationError = null;

/**
 * @summary Delete webhook
 */
export const useWebhooksControllerDelete = <TError = null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof webhooksControllerDelete>>,
      TError,
      { organizationId: string; id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof webhooksControllerDelete>>,
  TError,
  { organizationId: string; id: string },
  TContext
> => {
  const mutationOptions = getWebhooksControllerDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Toggle webhook active status
 */
export const webhooksControllerToggleActive = (
  organizationId: string,
  id: string,
) => {
  return customInstance<WebhookResponseDto>({
    url: `/api/v1/organizations/${organizationId}/webhooks/${id}/toggle`,
    method: "PATCH",
  });
};

export const getWebhooksControllerToggleActiveMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhooksControllerToggleActive>>,
    TError,
    { organizationId: string; id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhooksControllerToggleActive>>,
  TError,
  { organizationId: string; id: string },
  TContext
> => {
  const mutationKey = ["webhooksControllerToggleActive"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhooksControllerToggleActive>>,
    { organizationId: string; id: string }
  > = (props) => {
    const { organizationId, id } = props ?? {};

    return webhooksControllerToggleActive(organizationId, id);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhooksControllerToggleActiveMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhooksControllerToggleActive>>
>;

export type WebhooksControllerToggleActiveMutationError = null;

/**
 * @summary Toggle webhook active status
 */
export const useWebhooksControllerToggleActive = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof webhooksControllerToggleActive>>,
      TError,
      { organizationId: string; id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof webhooksControllerToggleActive>>,
  TError,
  { organizationId: string; id: string },
  TContext
> => {
  const mutationOptions =
    getWebhooksControllerToggleActiveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Handle OAuth callback and exchange code for tokens
 * @summary Handle OAuth callback
 */
export const calendarControllerHandleOAuthCallback = (
  params: CalendarControllerHandleOAuthCallbackParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/calendar/callback`,
    method: "GET",
    params,
    signal,
  });
};

export const getCalendarControllerHandleOAuthCallbackQueryKey = (
  params?: CalendarControllerHandleOAuthCallbackParams,
) => {
  return [`/api/v1/calendar/callback`, ...(params ? [params] : [])] as const;
};

export const getCalendarControllerHandleOAuthCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
  TError = null,
>(
  params: CalendarControllerHandleOAuthCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCalendarControllerHandleOAuthCallbackQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>
  > = ({ signal }) => calendarControllerHandleOAuthCallback(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CalendarControllerHandleOAuthCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>
>;
export type CalendarControllerHandleOAuthCallbackQueryError = null;

export function useCalendarControllerHandleOAuthCallback<
  TData = Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
  TError = null,
>(
  params: CalendarControllerHandleOAuthCallbackParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useCalendarControllerHandleOAuthCallback<
  TData = Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
  TError = null,
>(
  params: CalendarControllerHandleOAuthCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCalendarControllerHandleOAuthCallback<
  TData = Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
  TError = null,
>(
  params: CalendarControllerHandleOAuthCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Handle OAuth callback
 */

export function useCalendarControllerHandleOAuthCallback<
  TData = Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
  TError = null,
>(
  params: CalendarControllerHandleOAuthCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerHandleOAuthCallback>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCalendarControllerHandleOAuthCallbackQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Generate OAuth URL for frontend to initiate calendar connection
 * @summary Generate OAuth URL for frontend
 */
export const calendarControllerGenerateOAuthUrl = (
  params: CalendarControllerGenerateOAuthUrlParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/calendar/generate-oauth-url`,
    method: "GET",
    params,
    signal,
  });
};

export const getCalendarControllerGenerateOAuthUrlQueryKey = (
  params?: CalendarControllerGenerateOAuthUrlParams,
) => {
  return [
    `/api/v1/calendar/generate-oauth-url`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCalendarControllerGenerateOAuthUrlQueryOptions = <
  TData = Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
  TError = null,
>(
  params: CalendarControllerGenerateOAuthUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCalendarControllerGenerateOAuthUrlQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>
  > = ({ signal }) => calendarControllerGenerateOAuthUrl(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CalendarControllerGenerateOAuthUrlQueryResult = NonNullable<
  Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>
>;
export type CalendarControllerGenerateOAuthUrlQueryError = null;

export function useCalendarControllerGenerateOAuthUrl<
  TData = Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
  TError = null,
>(
  params: CalendarControllerGenerateOAuthUrlParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useCalendarControllerGenerateOAuthUrl<
  TData = Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
  TError = null,
>(
  params: CalendarControllerGenerateOAuthUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCalendarControllerGenerateOAuthUrl<
  TData = Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
  TError = null,
>(
  params: CalendarControllerGenerateOAuthUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Generate OAuth URL for frontend
 */

export function useCalendarControllerGenerateOAuthUrl<
  TData = Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
  TError = null,
>(
  params: CalendarControllerGenerateOAuthUrlParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGenerateOAuthUrl>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCalendarControllerGenerateOAuthUrlQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get the sync status of Google and Microsoft calendars
 * @summary Get calendar sync status
 */
export const calendarControllerGetCalendarSyncStatus = (
  params: CalendarControllerGetCalendarSyncStatusParams,
  signal?: AbortSignal,
) => {
  return customInstance<CalendarSyncStatusDto>({
    url: `/api/v1/calendar/sync-status`,
    method: "GET",
    params,
    signal,
  });
};

export const getCalendarControllerGetCalendarSyncStatusQueryKey = (
  params?: CalendarControllerGetCalendarSyncStatusParams,
) => {
  return [`/api/v1/calendar/sync-status`, ...(params ? [params] : [])] as const;
};

export const getCalendarControllerGetCalendarSyncStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetCalendarSyncStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCalendarControllerGetCalendarSyncStatusQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>
  > = ({ signal }) => calendarControllerGetCalendarSyncStatus(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CalendarControllerGetCalendarSyncStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>
>;
export type CalendarControllerGetCalendarSyncStatusQueryError = null;

export function useCalendarControllerGetCalendarSyncStatus<
  TData = Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetCalendarSyncStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useCalendarControllerGetCalendarSyncStatus<
  TData = Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetCalendarSyncStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCalendarControllerGetCalendarSyncStatus<
  TData = Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetCalendarSyncStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get calendar sync status
 */

export function useCalendarControllerGetCalendarSyncStatus<
  TData = Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetCalendarSyncStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetCalendarSyncStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCalendarControllerGetCalendarSyncStatusQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Disconnect calendar integration for a specific provider
 * @summary Disconnect calendar integration
 */
export const calendarControllerDisconnectCalendar = (
  params: CalendarControllerDisconnectCalendarParams,
) => {
  return customInstance<DisconnectCalendarResponseDto>({
    url: `/api/v1/calendar/disconnect`,
    method: "DELETE",
    params,
  });
};

export const getCalendarControllerDisconnectCalendarMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof calendarControllerDisconnectCalendar>>,
    TError,
    { params: CalendarControllerDisconnectCalendarParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof calendarControllerDisconnectCalendar>>,
  TError,
  { params: CalendarControllerDisconnectCalendarParams },
  TContext
> => {
  const mutationKey = ["calendarControllerDisconnectCalendar"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof calendarControllerDisconnectCalendar>>,
    { params: CalendarControllerDisconnectCalendarParams }
  > = (props) => {
    const { params } = props ?? {};

    return calendarControllerDisconnectCalendar(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CalendarControllerDisconnectCalendarMutationResult = NonNullable<
  Awaited<ReturnType<typeof calendarControllerDisconnectCalendar>>
>;

export type CalendarControllerDisconnectCalendarMutationError = null;

/**
 * @summary Disconnect calendar integration
 */
export const useCalendarControllerDisconnectCalendar = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof calendarControllerDisconnectCalendar>>,
      TError,
      { params: CalendarControllerDisconnectCalendarParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof calendarControllerDisconnectCalendar>>,
  TError,
  { params: CalendarControllerDisconnectCalendarParams },
  TContext
> => {
  const mutationOptions =
    getCalendarControllerDisconnectCalendarMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get a list of available calendars from the connected provider
 * @summary List available calendars for selection
 */
export const calendarControllerListAvailableCalendars = (
  params: CalendarControllerListAvailableCalendarsParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/calendar/available-calendars`,
    method: "GET",
    params,
    signal,
  });
};

export const getCalendarControllerListAvailableCalendarsQueryKey = (
  params?: CalendarControllerListAvailableCalendarsParams,
) => {
  return [
    `/api/v1/calendar/available-calendars`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCalendarControllerListAvailableCalendarsQueryOptions = <
  TData = Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
  TError = null,
>(
  params: CalendarControllerListAvailableCalendarsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCalendarControllerListAvailableCalendarsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>
  > = ({ signal }) => calendarControllerListAvailableCalendars(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CalendarControllerListAvailableCalendarsQueryResult = NonNullable<
  Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>
>;
export type CalendarControllerListAvailableCalendarsQueryError = null;

export function useCalendarControllerListAvailableCalendars<
  TData = Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
  TError = null,
>(
  params: CalendarControllerListAvailableCalendarsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useCalendarControllerListAvailableCalendars<
  TData = Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
  TError = null,
>(
  params: CalendarControllerListAvailableCalendarsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCalendarControllerListAvailableCalendars<
  TData = Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
  TError = null,
>(
  params: CalendarControllerListAvailableCalendarsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary List available calendars for selection
 */

export function useCalendarControllerListAvailableCalendars<
  TData = Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
  TError = null,
>(
  params: CalendarControllerListAvailableCalendarsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListAvailableCalendars>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCalendarControllerListAvailableCalendarsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get a list of calendars from the database that are synced for the user
 * @summary List my synced calendars
 */
export const calendarControllerListMyCalendars = (
  params: CalendarControllerListMyCalendarsParams,
  signal?: AbortSignal,
) => {
  return customInstance<ListMyCalendarsResponseDto>({
    url: `/api/v1/calendar/my-calendars`,
    method: "GET",
    params,
    signal,
  });
};

export const getCalendarControllerListMyCalendarsQueryKey = (
  params?: CalendarControllerListMyCalendarsParams,
) => {
  return [
    `/api/v1/calendar/my-calendars`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCalendarControllerListMyCalendarsQueryOptions = <
  TData = Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
  TError = null,
>(
  params: CalendarControllerListMyCalendarsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCalendarControllerListMyCalendarsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof calendarControllerListMyCalendars>>
  > = ({ signal }) => calendarControllerListMyCalendars(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CalendarControllerListMyCalendarsQueryResult = NonNullable<
  Awaited<ReturnType<typeof calendarControllerListMyCalendars>>
>;
export type CalendarControllerListMyCalendarsQueryError = null;

export function useCalendarControllerListMyCalendars<
  TData = Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
  TError = null,
>(
  params: CalendarControllerListMyCalendarsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerListMyCalendars>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useCalendarControllerListMyCalendars<
  TData = Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
  TError = null,
>(
  params: CalendarControllerListMyCalendarsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerListMyCalendars>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCalendarControllerListMyCalendars<
  TData = Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
  TError = null,
>(
  params: CalendarControllerListMyCalendarsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary List my synced calendars
 */

export function useCalendarControllerListMyCalendars<
  TData = Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
  TError = null,
>(
  params: CalendarControllerListMyCalendarsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerListMyCalendars>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCalendarControllerListMyCalendarsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get detailed information about synced events and calendars
 * @summary Get event sync status
 */
export const calendarControllerGetEventSyncStatus = (
  params: CalendarControllerGetEventSyncStatusParams,
  signal?: AbortSignal,
) => {
  return customInstance<EventSyncStatusResponseDto>({
    url: `/api/v1/calendar/event-sync-status`,
    method: "GET",
    params,
    signal,
  });
};

export const getCalendarControllerGetEventSyncStatusQueryKey = (
  params?: CalendarControllerGetEventSyncStatusParams,
) => {
  return [
    `/api/v1/calendar/event-sync-status`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCalendarControllerGetEventSyncStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetEventSyncStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCalendarControllerGetEventSyncStatusQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>
  > = ({ signal }) => calendarControllerGetEventSyncStatus(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type CalendarControllerGetEventSyncStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>
>;
export type CalendarControllerGetEventSyncStatusQueryError = null;

export function useCalendarControllerGetEventSyncStatus<
  TData = Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetEventSyncStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useCalendarControllerGetEventSyncStatus<
  TData = Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetEventSyncStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
          TError,
          Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useCalendarControllerGetEventSyncStatus<
  TData = Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetEventSyncStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get event sync status
 */

export function useCalendarControllerGetEventSyncStatus<
  TData = Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
  TError = null,
>(
  params: CalendarControllerGetEventSyncStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calendarControllerGetEventSyncStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getCalendarControllerGetEventSyncStatusQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Refresh calendars for the authenticated user
 * @summary Refresh calendars
 */
export const calendarControllerRefreshCalendarsByOrganization = (
  params: CalendarControllerRefreshCalendarsByOrganizationParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/calendar/refresh`,
    method: "POST",
    params,
    signal,
  });
};

export const getCalendarControllerRefreshCalendarsByOrganizationMutationOptions =
  <TError = null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof calendarControllerRefreshCalendarsByOrganization>
      >,
      TError,
      { params: CalendarControllerRefreshCalendarsByOrganizationParams },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof calendarControllerRefreshCalendarsByOrganization>
    >,
    TError,
    { params: CalendarControllerRefreshCalendarsByOrganizationParams },
    TContext
  > => {
    const mutationKey = ["calendarControllerRefreshCalendarsByOrganization"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof calendarControllerRefreshCalendarsByOrganization>
      >,
      { params: CalendarControllerRefreshCalendarsByOrganizationParams }
    > = (props) => {
      const { params } = props ?? {};

      return calendarControllerRefreshCalendarsByOrganization(params);
    };

    return { mutationFn, ...mutationOptions };
  };

export type CalendarControllerRefreshCalendarsByOrganizationMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof calendarControllerRefreshCalendarsByOrganization>>
  >;

export type CalendarControllerRefreshCalendarsByOrganizationMutationError =
  null;

/**
 * @summary Refresh calendars
 */
export const useCalendarControllerRefreshCalendarsByOrganization = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof calendarControllerRefreshCalendarsByOrganization>
      >,
      TError,
      { params: CalendarControllerRefreshCalendarsByOrganizationParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof calendarControllerRefreshCalendarsByOrganization>>,
  TError,
  { params: CalendarControllerRefreshCalendarsByOrganizationParams },
  TContext
> => {
  const mutationOptions =
    getCalendarControllerRefreshCalendarsByOrganizationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Sync a specific calendar
 * @summary Sync specific calendar
 */
export const calendarControllerSyncSpecificCalendar = (
  params: CalendarControllerSyncSpecificCalendarParams,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/calendar/sync`,
    method: "POST",
    params,
    signal,
  });
};

export const getCalendarControllerSyncSpecificCalendarMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof calendarControllerSyncSpecificCalendar>>,
    TError,
    { params: CalendarControllerSyncSpecificCalendarParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof calendarControllerSyncSpecificCalendar>>,
  TError,
  { params: CalendarControllerSyncSpecificCalendarParams },
  TContext
> => {
  const mutationKey = ["calendarControllerSyncSpecificCalendar"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof calendarControllerSyncSpecificCalendar>>,
    { params: CalendarControllerSyncSpecificCalendarParams }
  > = (props) => {
    const { params } = props ?? {};

    return calendarControllerSyncSpecificCalendar(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CalendarControllerSyncSpecificCalendarMutationResult = NonNullable<
  Awaited<ReturnType<typeof calendarControllerSyncSpecificCalendar>>
>;

export type CalendarControllerSyncSpecificCalendarMutationError = null;

/**
 * @summary Sync specific calendar
 */
export const useCalendarControllerSyncSpecificCalendar = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof calendarControllerSyncSpecificCalendar>>,
      TError,
      { params: CalendarControllerSyncSpecificCalendarParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof calendarControllerSyncSpecificCalendar>>,
  TError,
  { params: CalendarControllerSyncSpecificCalendarParams },
  TContext
> => {
  const mutationOptions =
    getCalendarControllerSyncSpecificCalendarMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Unsync a specific calendar
 * @summary Unsync specific calendar
 */
export const calendarControllerUnsyncSpecificCalendar = (
  params: CalendarControllerUnsyncSpecificCalendarParams,
) => {
  return customInstance<null>({
    url: `/api/v1/calendar/unsync`,
    method: "DELETE",
    params,
  });
};

export const getCalendarControllerUnsyncSpecificCalendarMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof calendarControllerUnsyncSpecificCalendar>>,
    TError,
    { params: CalendarControllerUnsyncSpecificCalendarParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof calendarControllerUnsyncSpecificCalendar>>,
  TError,
  { params: CalendarControllerUnsyncSpecificCalendarParams },
  TContext
> => {
  const mutationKey = ["calendarControllerUnsyncSpecificCalendar"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof calendarControllerUnsyncSpecificCalendar>>,
    { params: CalendarControllerUnsyncSpecificCalendarParams }
  > = (props) => {
    const { params } = props ?? {};

    return calendarControllerUnsyncSpecificCalendar(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CalendarControllerUnsyncSpecificCalendarMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof calendarControllerUnsyncSpecificCalendar>>
  >;

export type CalendarControllerUnsyncSpecificCalendarMutationError = null;

/**
 * @summary Unsync specific calendar
 */
export const useCalendarControllerUnsyncSpecificCalendar = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof calendarControllerUnsyncSpecificCalendar>>,
      TError,
      { params: CalendarControllerUnsyncSpecificCalendarParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof calendarControllerUnsyncSpecificCalendar>>,
  TError,
  { params: CalendarControllerUnsyncSpecificCalendarParams },
  TContext
> => {
  const mutationOptions =
    getCalendarControllerUnsyncSpecificCalendarMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Receives meeting completion data from MeetingBaaS and tracks usage
 * @summary Handle MeetingBaaS meeting completion webhook
 */
export const meetingBaasWebhookControllerHandleMeetingCompleted = (
  meetingBaasWebhookDto: MeetingBaasWebhookDto,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/webhooks/meetingbaas/meeting-completed`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: meetingBaasWebhookDto,
    signal,
  });
};

export const getMeetingBaasWebhookControllerHandleMeetingCompletedMutationOptions =
  <TError = null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof meetingBaasWebhookControllerHandleMeetingCompleted>
      >,
      TError,
      { data: MeetingBaasWebhookDto },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof meetingBaasWebhookControllerHandleMeetingCompleted>
    >,
    TError,
    { data: MeetingBaasWebhookDto },
    TContext
  > => {
    const mutationKey = ["meetingBaasWebhookControllerHandleMeetingCompleted"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof meetingBaasWebhookControllerHandleMeetingCompleted>
      >,
      { data: MeetingBaasWebhookDto }
    > = (props) => {
      const { data } = props ?? {};

      return meetingBaasWebhookControllerHandleMeetingCompleted(data);
    };

    return { mutationFn, ...mutationOptions };
  };

export type MeetingBaasWebhookControllerHandleMeetingCompletedMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof meetingBaasWebhookControllerHandleMeetingCompleted>
    >
  >;
export type MeetingBaasWebhookControllerHandleMeetingCompletedMutationBody =
  MeetingBaasWebhookDto;
export type MeetingBaasWebhookControllerHandleMeetingCompletedMutationError =
  null;

/**
 * @summary Handle MeetingBaaS meeting completion webhook
 */
export const useMeetingBaasWebhookControllerHandleMeetingCompleted = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof meetingBaasWebhookControllerHandleMeetingCompleted>
      >,
      TError,
      { data: MeetingBaasWebhookDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof meetingBaasWebhookControllerHandleMeetingCompleted>
  >,
  TError,
  { data: MeetingBaasWebhookDto },
  TContext
> => {
  const mutationOptions =
    getMeetingBaasWebhookControllerHandleMeetingCompletedMutationOptions(
      options,
    );

  return useMutation(mutationOptions, queryClient);
};

/**
 * Receives meeting start data from MeetingBaaS
 * @summary Handle MeetingBaaS meeting start webhook
 */
export const meetingBaasWebhookControllerHandleMeetingStarted = (
  meetingBaasWebhookDto: MeetingBaasWebhookDto,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/webhooks/meetingbaas/meeting-started`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: meetingBaasWebhookDto,
    signal,
  });
};

export const getMeetingBaasWebhookControllerHandleMeetingStartedMutationOptions =
  <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof meetingBaasWebhookControllerHandleMeetingStarted>
      >,
      TError,
      { data: MeetingBaasWebhookDto },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof meetingBaasWebhookControllerHandleMeetingStarted>
    >,
    TError,
    { data: MeetingBaasWebhookDto },
    TContext
  > => {
    const mutationKey = ["meetingBaasWebhookControllerHandleMeetingStarted"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof meetingBaasWebhookControllerHandleMeetingStarted>
      >,
      { data: MeetingBaasWebhookDto }
    > = (props) => {
      const { data } = props ?? {};

      return meetingBaasWebhookControllerHandleMeetingStarted(data);
    };

    return { mutationFn, ...mutationOptions };
  };

export type MeetingBaasWebhookControllerHandleMeetingStartedMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof meetingBaasWebhookControllerHandleMeetingStarted>>
  >;
export type MeetingBaasWebhookControllerHandleMeetingStartedMutationBody =
  MeetingBaasWebhookDto;
export type MeetingBaasWebhookControllerHandleMeetingStartedMutationError =
  unknown;

/**
 * @summary Handle MeetingBaaS meeting start webhook
 */
export const useMeetingBaasWebhookControllerHandleMeetingStarted = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof meetingBaasWebhookControllerHandleMeetingStarted>
      >,
      TError,
      { data: MeetingBaasWebhookDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof meetingBaasWebhookControllerHandleMeetingStarted>>,
  TError,
  { data: MeetingBaasWebhookDto },
  TContext
> => {
  const mutationOptions =
    getMeetingBaasWebhookControllerHandleMeetingStartedMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Creates a free trial checkout session using the authenticated user's profile information. Seats are hardcoded to 1.
 * @summary Create a checkout session for free trial with automatic billing after trial
 */
export const paymentControllerCreateFreeTrialCheckoutSession = (
  params: PaymentControllerCreateFreeTrialCheckoutSessionParams,
  signal?: AbortSignal,
) => {
  return customInstance<CreateCheckoutSessionDto>({
    url: `/api/v1/payment/create-free-trial-checkout-session`,
    method: "POST",
    params,
    signal,
  });
};

export const getPaymentControllerCreateFreeTrialCheckoutSessionMutationOptions =
  <TError = null | null, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof paymentControllerCreateFreeTrialCheckoutSession>
      >,
      TError,
      { params: PaymentControllerCreateFreeTrialCheckoutSessionParams },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof paymentControllerCreateFreeTrialCheckoutSession>>,
    TError,
    { params: PaymentControllerCreateFreeTrialCheckoutSessionParams },
    TContext
  > => {
    const mutationKey = ["paymentControllerCreateFreeTrialCheckoutSession"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof paymentControllerCreateFreeTrialCheckoutSession>
      >,
      { params: PaymentControllerCreateFreeTrialCheckoutSessionParams }
    > = (props) => {
      const { params } = props ?? {};

      return paymentControllerCreateFreeTrialCheckoutSession(params);
    };

    return { mutationFn, ...mutationOptions };
  };

export type PaymentControllerCreateFreeTrialCheckoutSessionMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof paymentControllerCreateFreeTrialCheckoutSession>>
  >;

export type PaymentControllerCreateFreeTrialCheckoutSessionMutationError =
  | null
  | null;

/**
 * @summary Create a checkout session for free trial with automatic billing after trial
 */
export const usePaymentControllerCreateFreeTrialCheckoutSession = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof paymentControllerCreateFreeTrialCheckoutSession>
      >,
      TError,
      { params: PaymentControllerCreateFreeTrialCheckoutSessionParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof paymentControllerCreateFreeTrialCheckoutSession>>,
  TError,
  { params: PaymentControllerCreateFreeTrialCheckoutSessionParams },
  TContext
> => {
  const mutationOptions =
    getPaymentControllerCreateFreeTrialCheckoutSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Creates a checkout session for a new subscription plan with specified seats and billing cycle.
 * @summary Create a checkout session for new subscription
 */
export const paymentControllerCreateCheckoutSession = (
  createCheckoutSessionDto: CreateCheckoutSessionDto,
  signal?: AbortSignal,
) => {
  return customInstance<CheckoutSessionResponseDto>({
    url: `/api/v1/payment/create-checkout-session`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createCheckoutSessionDto,
    signal,
  });
};

export const getPaymentControllerCreateCheckoutSessionMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentControllerCreateCheckoutSession>>,
    TError,
    { data: CreateCheckoutSessionDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentControllerCreateCheckoutSession>>,
  TError,
  { data: CreateCheckoutSessionDto },
  TContext
> => {
  const mutationKey = ["paymentControllerCreateCheckoutSession"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentControllerCreateCheckoutSession>>,
    { data: CreateCheckoutSessionDto }
  > = (props) => {
    const { data } = props ?? {};

    return paymentControllerCreateCheckoutSession(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentControllerCreateCheckoutSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerCreateCheckoutSession>>
>;
export type PaymentControllerCreateCheckoutSessionMutationBody =
  CreateCheckoutSessionDto;
export type PaymentControllerCreateCheckoutSessionMutationError = null | null;

/**
 * @summary Create a checkout session for new subscription
 */
export const usePaymentControllerCreateCheckoutSession = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof paymentControllerCreateCheckoutSession>>,
      TError,
      { data: CreateCheckoutSessionDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof paymentControllerCreateCheckoutSession>>,
  TError,
  { data: CreateCheckoutSessionDto },
  TContext
> => {
  const mutationOptions =
    getPaymentControllerCreateCheckoutSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Handle payment webhook events
 */
export const paymentControllerHandleWebhook = (signal?: AbortSignal) => {
  return customInstance<null>({
    url: `/api/v1/payment/webhook`,
    method: "POST",
    signal,
  });
};

export const getPaymentControllerHandleWebhookMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentControllerHandleWebhook>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentControllerHandleWebhook>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["paymentControllerHandleWebhook"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentControllerHandleWebhook>>,
    void
  > = () => {
    return paymentControllerHandleWebhook();
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentControllerHandleWebhookMutationResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerHandleWebhook>>
>;

export type PaymentControllerHandleWebhookMutationError = unknown;

/**
 * @summary Handle payment webhook events
 */
export const usePaymentControllerHandleWebhook = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof paymentControllerHandleWebhook>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof paymentControllerHandleWebhook>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getPaymentControllerHandleWebhookMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Cancel a subscription
 */
export const paymentControllerCancelSubscription = (
  subscriptionId: string,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/payment/subscription/${subscriptionId}/cancel`,
    method: "POST",
    signal,
  });
};

export const getPaymentControllerCancelSubscriptionMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentControllerCancelSubscription>>,
    TError,
    { subscriptionId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentControllerCancelSubscription>>,
  TError,
  { subscriptionId: string },
  TContext
> => {
  const mutationKey = ["paymentControllerCancelSubscription"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentControllerCancelSubscription>>,
    { subscriptionId: string }
  > = (props) => {
    const { subscriptionId } = props ?? {};

    return paymentControllerCancelSubscription(subscriptionId);
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentControllerCancelSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerCancelSubscription>>
>;

export type PaymentControllerCancelSubscriptionMutationError = unknown;

/**
 * @summary Cancel a subscription
 */
export const usePaymentControllerCancelSubscription = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof paymentControllerCancelSubscription>>,
      TError,
      { subscriptionId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof paymentControllerCancelSubscription>>,
  TError,
  { subscriptionId: string },
  TContext
> => {
  const mutationOptions =
    getPaymentControllerCancelSubscriptionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Update both the number of seats and the plan tier for a subscription. All fields are required.
 * @summary Update subscription seats count and plan tier
 */
export const paymentControllerUpdateSubscriptionSeats = (
  subscriptionId: string,
  updateSubscriptionSeatsDto: UpdateSubscriptionSeatsDto,
  params: PaymentControllerUpdateSubscriptionSeatsParams,
  signal?: AbortSignal,
) => {
  return customInstance<PaymentControllerUpdateSubscriptionSeats200>({
    url: `/api/v1/payment/subscription/${subscriptionId}/update-seats`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: updateSubscriptionSeatsDto,
    params,
    signal,
  });
};

export const getPaymentControllerUpdateSubscriptionSeatsMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentControllerUpdateSubscriptionSeats>>,
    TError,
    {
      subscriptionId: string;
      data: UpdateSubscriptionSeatsDto;
      params: PaymentControllerUpdateSubscriptionSeatsParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentControllerUpdateSubscriptionSeats>>,
  TError,
  {
    subscriptionId: string;
    data: UpdateSubscriptionSeatsDto;
    params: PaymentControllerUpdateSubscriptionSeatsParams;
  },
  TContext
> => {
  const mutationKey = ["paymentControllerUpdateSubscriptionSeats"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentControllerUpdateSubscriptionSeats>>,
    {
      subscriptionId: string;
      data: UpdateSubscriptionSeatsDto;
      params: PaymentControllerUpdateSubscriptionSeatsParams;
    }
  > = (props) => {
    const { subscriptionId, data, params } = props ?? {};

    return paymentControllerUpdateSubscriptionSeats(
      subscriptionId,
      data,
      params,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentControllerUpdateSubscriptionSeatsMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof paymentControllerUpdateSubscriptionSeats>>
  >;
export type PaymentControllerUpdateSubscriptionSeatsMutationBody =
  UpdateSubscriptionSeatsDto;
export type PaymentControllerUpdateSubscriptionSeatsMutationError = null | null;

/**
 * @summary Update subscription seats count and plan tier
 */
export const usePaymentControllerUpdateSubscriptionSeats = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof paymentControllerUpdateSubscriptionSeats>>,
      TError,
      {
        subscriptionId: string;
        data: UpdateSubscriptionSeatsDto;
        params: PaymentControllerUpdateSubscriptionSeatsParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof paymentControllerUpdateSubscriptionSeats>>,
  TError,
  {
    subscriptionId: string;
    data: UpdateSubscriptionSeatsDto;
    params: PaymentControllerUpdateSubscriptionSeatsParams;
  },
  TContext
> => {
  const mutationOptions =
    getPaymentControllerUpdateSubscriptionSeatsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Check if adding additional seats would exceed the current plan's seat limit
 * @summary Validate seat addition for organization
 */
export const paymentControllerValidateSeatAddition = (
  organizationId: string,
  params: PaymentControllerValidateSeatAdditionParams,
  signal?: AbortSignal,
) => {
  return customInstance<SeatValidationDto>({
    url: `/api/v1/payment/seats/validate/${organizationId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getPaymentControllerValidateSeatAdditionQueryKey = (
  organizationId?: string,
  params?: PaymentControllerValidateSeatAdditionParams,
) => {
  return [
    `/api/v1/payment/seats/validate/${organizationId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPaymentControllerValidateSeatAdditionQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
  TError = null | null,
>(
  organizationId: string,
  params: PaymentControllerValidateSeatAdditionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerValidateSeatAdditionQueryKey(organizationId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>
  > = ({ signal }) =>
    paymentControllerValidateSeatAddition(organizationId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerValidateSeatAdditionQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>
>;
export type PaymentControllerValidateSeatAdditionQueryError = null | null;

export function usePaymentControllerValidateSeatAddition<
  TData = Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
  TError = null | null,
>(
  organizationId: string,
  params: PaymentControllerValidateSeatAdditionParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerValidateSeatAddition<
  TData = Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
  TError = null | null,
>(
  organizationId: string,
  params: PaymentControllerValidateSeatAdditionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerValidateSeatAddition<
  TData = Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
  TError = null | null,
>(
  organizationId: string,
  params: PaymentControllerValidateSeatAdditionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Validate seat addition for organization
 */

export function usePaymentControllerValidateSeatAddition<
  TData = Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
  TError = null | null,
>(
  organizationId: string,
  params: PaymentControllerValidateSeatAdditionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerValidateSeatAddition>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerValidateSeatAdditionQueryOptions(
    organizationId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve current seat usage statistics including usage percentage
 * @summary Get current seat usage for organization
 */
export const paymentControllerGetCurrentSeatUsage = (
  organizationId: string,
  signal?: AbortSignal,
) => {
  return customInstance<SeatUsageDto>({
    url: `/api/v1/payment/seats/usage/${organizationId}`,
    method: "GET",
    signal,
  });
};

export const getPaymentControllerGetCurrentSeatUsageQueryKey = (
  organizationId?: string,
) => {
  return [`/api/v1/payment/seats/usage/${organizationId}`] as const;
};

export const getPaymentControllerGetCurrentSeatUsageQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerGetCurrentSeatUsageQueryKey(organizationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>
  > = ({ signal }) =>
    paymentControllerGetCurrentSeatUsage(organizationId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerGetCurrentSeatUsageQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>
>;
export type PaymentControllerGetCurrentSeatUsageQueryError = null;

export function usePaymentControllerGetCurrentSeatUsage<
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
  TError = null,
>(
  organizationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerGetCurrentSeatUsage<
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerGetCurrentSeatUsage<
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get current seat usage for organization
 */

export function usePaymentControllerGetCurrentSeatUsage<
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentSeatUsage>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerGetCurrentSeatUsageQueryOptions(
    organizationId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Analyze current seat usage and recommend plan upgrades if needed
 * @summary Check if organization needs to upgrade plan
 */
export const paymentControllerCheckUpgradeNeeded = (
  organizationId: string,
  signal?: AbortSignal,
) => {
  return customInstance<UpgradeCheckDto>({
    url: `/api/v1/payment/seats/upgrade-check/${organizationId}`,
    method: "GET",
    signal,
  });
};

export const getPaymentControllerCheckUpgradeNeededQueryKey = (
  organizationId?: string,
) => {
  return [`/api/v1/payment/seats/upgrade-check/${organizationId}`] as const;
};

export const getPaymentControllerCheckUpgradeNeededQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerCheckUpgradeNeededQueryKey(organizationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>
  > = ({ signal }) =>
    paymentControllerCheckUpgradeNeeded(organizationId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerCheckUpgradeNeededQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>
>;
export type PaymentControllerCheckUpgradeNeededQueryError = null;

export function usePaymentControllerCheckUpgradeNeeded<
  TData = Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
  TError = null,
>(
  organizationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerCheckUpgradeNeeded<
  TData = Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerCheckUpgradeNeeded<
  TData = Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Check if organization needs to upgrade plan
 */

export function usePaymentControllerCheckUpgradeNeeded<
  TData = Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
  TError = null,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerCheckUpgradeNeeded>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerCheckUpgradeNeededQueryOptions(
    organizationId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve the maximum number of seats allowed for a specific plan tier
 * @summary Get seat limit for a plan tier
 */
export const paymentControllerGetSeatLimitForPlan = (
  planTier: string,
  signal?: AbortSignal,
) => {
  return customInstance<PaymentControllerGetSeatLimitForPlan200>({
    url: `/api/v1/payment/seats/limit/${planTier}`,
    method: "GET",
    signal,
  });
};

export const getPaymentControllerGetSeatLimitForPlanQueryKey = (
  planTier?: string,
) => {
  return [`/api/v1/payment/seats/limit/${planTier}`] as const;
};

export const getPaymentControllerGetSeatLimitForPlanQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
  TError = null,
>(
  planTier: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerGetSeatLimitForPlanQueryKey(planTier);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>
  > = ({ signal }) => paymentControllerGetSeatLimitForPlan(planTier, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!planTier,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerGetSeatLimitForPlanQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>
>;
export type PaymentControllerGetSeatLimitForPlanQueryError = null;

export function usePaymentControllerGetSeatLimitForPlan<
  TData = Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
  TError = null,
>(
  planTier: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerGetSeatLimitForPlan<
  TData = Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
  TError = null,
>(
  planTier: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerGetSeatLimitForPlan<
  TData = Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
  TError = null,
>(
  planTier: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get seat limit for a plan tier
 */

export function usePaymentControllerGetSeatLimitForPlan<
  TData = Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
  TError = null,
>(
  planTier: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSeatLimitForPlan>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerGetSeatLimitForPlanQueryOptions(
    planTier,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Find all plan tiers that can accommodate the specified number of seats
 * @summary Get compatible plans for a seat count
 */
export const paymentControllerGetCompatiblePlans = (
  params: PaymentControllerGetCompatiblePlansParams,
  signal?: AbortSignal,
) => {
  return customInstance<PaymentControllerGetCompatiblePlans200>({
    url: `/api/v1/payment/seats/compatible-plans`,
    method: "GET",
    params,
    signal,
  });
};

export const getPaymentControllerGetCompatiblePlansQueryKey = (
  params?: PaymentControllerGetCompatiblePlansParams,
) => {
  return [
    `/api/v1/payment/seats/compatible-plans`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPaymentControllerGetCompatiblePlansQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
  TError = null,
>(
  params: PaymentControllerGetCompatiblePlansParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerGetCompatiblePlansQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>
  > = ({ signal }) => paymentControllerGetCompatiblePlans(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerGetCompatiblePlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>
>;
export type PaymentControllerGetCompatiblePlansQueryError = null;

export function usePaymentControllerGetCompatiblePlans<
  TData = Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
  TError = null,
>(
  params: PaymentControllerGetCompatiblePlansParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerGetCompatiblePlans<
  TData = Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
  TError = null,
>(
  params: PaymentControllerGetCompatiblePlansParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerGetCompatiblePlans<
  TData = Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
  TError = null,
>(
  params: PaymentControllerGetCompatiblePlansParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get compatible plans for a seat count
 */

export function usePaymentControllerGetCompatiblePlans<
  TData = Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
  TError = null,
>(
  params: PaymentControllerGetCompatiblePlansParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCompatiblePlans>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerGetCompatiblePlansQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get detailed subscription information for an organization
 */
export const paymentControllerGetOrganizationSubscriptionDetails = (
  organizationId: string,
  signal?: AbortSignal,
) => {
  return customInstance<SubscriptionDetailsResponseDto>({
    url: `/api/v1/payment/organization/${organizationId}/subscription-details`,
    method: "GET",
    signal,
  });
};

export const getPaymentControllerGetOrganizationSubscriptionDetailsQueryKey = (
  organizationId?: string,
) => {
  return [
    `/api/v1/payment/organization/${organizationId}/subscription-details`,
  ] as const;
};

export const getPaymentControllerGetOrganizationSubscriptionDetailsQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
    >,
    TError = unknown,
  >(
    organizationId: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof paymentControllerGetOrganizationSubscriptionDetails
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getPaymentControllerGetOrganizationSubscriptionDetailsQueryKey(
        organizationId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
      >
    > = ({ signal }) =>
      paymentControllerGetOrganizationSubscriptionDetails(
        organizationId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!organizationId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData> };
  };

export type PaymentControllerGetOrganizationSubscriptionDetailsQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
    >
  >;
export type PaymentControllerGetOrganizationSubscriptionDetailsQueryError =
  unknown;

export function usePaymentControllerGetOrganizationSubscriptionDetails<
  TData = Awaited<
    ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
  >,
  TError = unknown,
>(
  organizationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof paymentControllerGetOrganizationSubscriptionDetails
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof paymentControllerGetOrganizationSubscriptionDetails
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerGetOrganizationSubscriptionDetails<
  TData = Awaited<
    ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
  >,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof paymentControllerGetOrganizationSubscriptionDetails
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof paymentControllerGetOrganizationSubscriptionDetails
            >
          >
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerGetOrganizationSubscriptionDetails<
  TData = Awaited<
    ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
  >,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get detailed subscription information for an organization
 */

export function usePaymentControllerGetOrganizationSubscriptionDetails<
  TData = Awaited<
    ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
  >,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof paymentControllerGetOrganizationSubscriptionDetails>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getPaymentControllerGetOrganizationSubscriptionDetailsQueryOptions(
      organizationId,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get subscription status for an organization
 */
export const paymentControllerGetSubscriptionStatus = (
  organizationId: string,
  signal?: AbortSignal,
) => {
  return customInstance<SubscriptionStatusResponseDto>({
    url: `/api/v1/payment/organization/${organizationId}/subscription-status`,
    method: "GET",
    signal,
  });
};

export const getPaymentControllerGetSubscriptionStatusQueryKey = (
  organizationId?: string,
) => {
  return [
    `/api/v1/payment/organization/${organizationId}/subscription-status`,
  ] as const;
};

export const getPaymentControllerGetSubscriptionStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerGetSubscriptionStatusQueryKey(organizationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>
  > = ({ signal }) =>
    paymentControllerGetSubscriptionStatus(organizationId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerGetSubscriptionStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>
>;
export type PaymentControllerGetSubscriptionStatusQueryError = unknown;

export function usePaymentControllerGetSubscriptionStatus<
  TData = Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
  TError = unknown,
>(
  organizationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerGetSubscriptionStatus<
  TData = Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerGetSubscriptionStatus<
  TData = Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get subscription status for an organization
 */

export function usePaymentControllerGetSubscriptionStatus<
  TData = Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetSubscriptionStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerGetSubscriptionStatusQueryOptions(
    organizationId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Check if organization has an active subscription
 */
export const paymentControllerHasSubscription = (
  organizationId: string,
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/payment/organization/${organizationId}/has-active-subscription`,
    method: "GET",
    signal,
  });
};

export const getPaymentControllerHasSubscriptionQueryKey = (
  organizationId?: string,
) => {
  return [
    `/api/v1/payment/organization/${organizationId}/has-active-subscription`,
  ] as const;
};

export const getPaymentControllerHasSubscriptionQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerHasSubscriptionQueryKey(organizationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerHasSubscription>>
  > = ({ signal }) => paymentControllerHasSubscription(organizationId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerHasSubscriptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerHasSubscription>>
>;
export type PaymentControllerHasSubscriptionQueryError = unknown;

export function usePaymentControllerHasSubscription<
  TData = Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
  TError = unknown,
>(
  organizationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerHasSubscription>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerHasSubscription<
  TData = Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerHasSubscription>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerHasSubscription<
  TData = Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Check if organization has an active subscription
 */

export function usePaymentControllerHasSubscription<
  TData = Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerHasSubscription>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerHasSubscriptionQueryOptions(
    organizationId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get payment history for an organization
 */
export const paymentControllerGetPaymentHistory = (
  organizationId: string,
  params: PaymentControllerGetPaymentHistoryParams,
  signal?: AbortSignal,
) => {
  return customInstance<PaymentHistoryResponseDto>({
    url: `/api/v1/payment/organization/${organizationId}/payment-history`,
    method: "GET",
    params,
    signal,
  });
};

export const getPaymentControllerGetPaymentHistoryQueryKey = (
  organizationId?: string,
  params?: PaymentControllerGetPaymentHistoryParams,
) => {
  return [
    `/api/v1/payment/organization/${organizationId}/payment-history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPaymentControllerGetPaymentHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetPaymentHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerGetPaymentHistoryQueryKey(organizationId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>
  > = ({ signal }) =>
    paymentControllerGetPaymentHistory(organizationId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerGetPaymentHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>
>;
export type PaymentControllerGetPaymentHistoryQueryError = unknown;

export function usePaymentControllerGetPaymentHistory<
  TData = Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetPaymentHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerGetPaymentHistory<
  TData = Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetPaymentHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerGetPaymentHistory<
  TData = Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetPaymentHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get payment history for an organization
 */

export function usePaymentControllerGetPaymentHistory<
  TData = Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetPaymentHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetPaymentHistory>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerGetPaymentHistoryQueryOptions(
    organizationId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get invoices for an organization
 */
export const paymentControllerGetInvoices = (
  organizationId: string,
  params: PaymentControllerGetInvoicesParams,
  signal?: AbortSignal,
) => {
  return customInstance<InvoiceResponseDto>({
    url: `/api/v1/payment/organization/${organizationId}/invoices`,
    method: "GET",
    params,
    signal,
  });
};

export const getPaymentControllerGetInvoicesQueryKey = (
  organizationId?: string,
  params?: PaymentControllerGetInvoicesParams,
) => {
  return [
    `/api/v1/payment/organization/${organizationId}/invoices`,
    ...(params ? [params] : []),
  ] as const;
};

export const getPaymentControllerGetInvoicesQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetInvoicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerGetInvoicesQueryKey(organizationId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerGetInvoices>>
  > = ({ signal }) =>
    paymentControllerGetInvoices(organizationId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerGetInvoicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerGetInvoices>>
>;
export type PaymentControllerGetInvoicesQueryError = unknown;

export function usePaymentControllerGetInvoices<
  TData = Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetInvoicesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetInvoices>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerGetInvoices<
  TData = Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetInvoicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetInvoices>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerGetInvoices<
  TData = Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetInvoicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get invoices for an organization
 */

export function usePaymentControllerGetInvoices<
  TData = Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
  TError = unknown,
>(
  organizationId: string,
  params: PaymentControllerGetInvoicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetInvoices>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerGetInvoicesQueryOptions(
    organizationId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get current plan information for an organization
 */
export const paymentControllerGetCurrentPlan = (
  params: PaymentControllerGetCurrentPlanParams,
  signal?: AbortSignal,
) => {
  return customInstance<CurrentPlanDto>({
    url: `/api/v1/payment/current-plan`,
    method: "GET",
    params,
    signal,
  });
};

export const getPaymentControllerGetCurrentPlanQueryKey = (
  params?: PaymentControllerGetCurrentPlanParams,
) => {
  return [`/api/v1/payment/current-plan`, ...(params ? [params] : [])] as const;
};

export const getPaymentControllerGetCurrentPlanQueryOptions = <
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
  TError = unknown,
>(
  params: PaymentControllerGetCurrentPlanParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPaymentControllerGetCurrentPlanQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>
  > = ({ signal }) => paymentControllerGetCurrentPlan(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PaymentControllerGetCurrentPlanQueryResult = NonNullable<
  Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>
>;
export type PaymentControllerGetCurrentPlanQueryError = unknown;

export function usePaymentControllerGetCurrentPlan<
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
  TError = unknown,
>(
  params: PaymentControllerGetCurrentPlanParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePaymentControllerGetCurrentPlan<
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
  TError = unknown,
>(
  params: PaymentControllerGetCurrentPlanParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePaymentControllerGetCurrentPlan<
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
  TError = unknown,
>(
  params: PaymentControllerGetCurrentPlanParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get current plan information for an organization
 */

export function usePaymentControllerGetCurrentPlan<
  TData = Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
  TError = unknown,
>(
  params: PaymentControllerGetCurrentPlanParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof paymentControllerGetCurrentPlan>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getPaymentControllerGetCurrentPlanQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a Stripe billing portal session that allows users to manage their subscription, update payment methods, and view billing history.
 * @summary Create a billing portal session for an organization
 */
export const paymentControllerCreateBillingPortalSession = (
  organizationId: string,
  params: PaymentControllerCreateBillingPortalSessionParams,
  signal?: AbortSignal,
) => {
  return customInstance<BillingPortalSessionResponseDto>({
    url: `/api/v1/payment/organization/${organizationId}/billing-portal-session`,
    method: "POST",
    params,
    signal,
  });
};

export const getPaymentControllerCreateBillingPortalSessionMutationOptions = <
  TError = null | null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof paymentControllerCreateBillingPortalSession>>,
    TError,
    {
      organizationId: string;
      params: PaymentControllerCreateBillingPortalSessionParams;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof paymentControllerCreateBillingPortalSession>>,
  TError,
  {
    organizationId: string;
    params: PaymentControllerCreateBillingPortalSessionParams;
  },
  TContext
> => {
  const mutationKey = ["paymentControllerCreateBillingPortalSession"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof paymentControllerCreateBillingPortalSession>>,
    {
      organizationId: string;
      params: PaymentControllerCreateBillingPortalSessionParams;
    }
  > = (props) => {
    const { organizationId, params } = props ?? {};

    return paymentControllerCreateBillingPortalSession(organizationId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type PaymentControllerCreateBillingPortalSessionMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof paymentControllerCreateBillingPortalSession>>
  >;

export type PaymentControllerCreateBillingPortalSessionMutationError =
  | null
  | null
  | null;

/**
 * @summary Create a billing portal session for an organization
 */
export const usePaymentControllerCreateBillingPortalSession = <
  TError = null | null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof paymentControllerCreateBillingPortalSession>>,
      TError,
      {
        organizationId: string;
        params: PaymentControllerCreateBillingPortalSessionParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof paymentControllerCreateBillingPortalSession>>,
  TError,
  {
    organizationId: string;
    params: PaymentControllerCreateBillingPortalSessionParams;
  },
  TContext
> => {
  const mutationOptions =
    getPaymentControllerCreateBillingPortalSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const stripeWebhookControllerHealthCheck = (signal?: AbortSignal) => {
  return customInstance<null>({
    url: `/api/v1/stripe/health`,
    method: "GET",
    signal,
  });
};

export const getStripeWebhookControllerHealthCheckQueryKey = () => {
  return [`/api/v1/stripe/health`] as const;
};

export const getStripeWebhookControllerHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStripeWebhookControllerHealthCheckQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>
  > = ({ signal }) => stripeWebhookControllerHealthCheck(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type StripeWebhookControllerHealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>
>;
export type StripeWebhookControllerHealthCheckQueryError = unknown;

export function useStripeWebhookControllerHealthCheck<
  TData = Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useStripeWebhookControllerHealthCheck<
  TData = Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useStripeWebhookControllerHealthCheck<
  TData = Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useStripeWebhookControllerHealthCheck<
  TData = Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stripeWebhookControllerHealthCheck>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getStripeWebhookControllerHealthCheckQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const stripeWebhookControllerTestWebhookConfig = (
  signal?: AbortSignal,
) => {
  return customInstance<null>({
    url: `/api/v1/stripe/test`,
    method: "GET",
    signal,
  });
};

export const getStripeWebhookControllerTestWebhookConfigQueryKey = () => {
  return [`/api/v1/stripe/test`] as const;
};

export const getStripeWebhookControllerTestWebhookConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getStripeWebhookControllerTestWebhookConfigQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>
  > = ({ signal }) => stripeWebhookControllerTestWebhookConfig(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type StripeWebhookControllerTestWebhookConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>
>;
export type StripeWebhookControllerTestWebhookConfigQueryError = unknown;

export function useStripeWebhookControllerTestWebhookConfig<
  TData = Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
          TError,
          Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useStripeWebhookControllerTestWebhookConfig<
  TData = Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
          TError,
          Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useStripeWebhookControllerTestWebhookConfig<
  TData = Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

export function useStripeWebhookControllerTestWebhookConfig<
  TData = Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stripeWebhookControllerTestWebhookConfig>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getStripeWebhookControllerTestWebhookConfigQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const stripeWebhookControllerHandleWebhook = (signal?: AbortSignal) => {
  return customInstance<null>({
    url: `/api/v1/stripe/webhook`,
    method: "POST",
    signal,
  });
};

export const getStripeWebhookControllerHandleWebhookMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stripeWebhookControllerHandleWebhook>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stripeWebhookControllerHandleWebhook>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["stripeWebhookControllerHandleWebhook"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stripeWebhookControllerHandleWebhook>>,
    void
  > = () => {
    return stripeWebhookControllerHandleWebhook();
  };

  return { mutationFn, ...mutationOptions };
};

export type StripeWebhookControllerHandleWebhookMutationResult = NonNullable<
  Awaited<ReturnType<typeof stripeWebhookControllerHandleWebhook>>
>;

export type StripeWebhookControllerHandleWebhookMutationError = unknown;

export const useStripeWebhookControllerHandleWebhook = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof stripeWebhookControllerHandleWebhook>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof stripeWebhookControllerHandleWebhook>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getStripeWebhookControllerHandleWebhookMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Public endpoint to retrieve all available payment plans and pricing information
 * @summary Get available payment plans
 */
export const publicPaymentControllerGetAvailablePlans = (
  signal?: AbortSignal,
) => {
  return customInstance<AvailablePlansResponseDto>({
    url: `/api/v1/payment/plans`,
    method: "GET",
    signal,
  });
};

export const getPublicPaymentControllerGetAvailablePlansQueryKey = () => {
  return [`/api/v1/payment/plans`] as const;
};

export const getPublicPaymentControllerGetAvailablePlansQueryOptions = <
  TData = Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPublicPaymentControllerGetAvailablePlansQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>
  > = ({ signal }) => publicPaymentControllerGetAvailablePlans(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type PublicPaymentControllerGetAvailablePlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>
>;
export type PublicPaymentControllerGetAvailablePlansQueryError = unknown;

export function usePublicPaymentControllerGetAvailablePlans<
  TData = Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
          TError,
          Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function usePublicPaymentControllerGetAvailablePlans<
  TData = Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
          TError,
          Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function usePublicPaymentControllerGetAvailablePlans<
  TData = Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get available payment plans
 */

export function usePublicPaymentControllerGetAvailablePlans<
  TData = Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof publicPaymentControllerGetAvailablePlans>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions =
    getPublicPaymentControllerGetAvailablePlansQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Health check endpoint
 */
export const healthControllerGetHealth = (signal?: AbortSignal) => {
  return customInstance<HealthControllerGetHealth200>({
    url: `/api/v1/health`,
    method: "GET",
    signal,
  });
};

export const getHealthControllerGetHealthQueryKey = () => {
  return [`/api/v1/health`] as const;
};

export const getHealthControllerGetHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof healthControllerGetHealth>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthControllerGetHealth>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getHealthControllerGetHealthQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof healthControllerGetHealth>>
  > = ({ signal }) => healthControllerGetHealth(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthControllerGetHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type HealthControllerGetHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthControllerGetHealth>>
>;
export type HealthControllerGetHealthQueryError = unknown;

export function useHealthControllerGetHealth<
  TData = Awaited<ReturnType<typeof healthControllerGetHealth>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthControllerGetHealth>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthControllerGetHealth>>,
          TError,
          Awaited<ReturnType<typeof healthControllerGetHealth>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useHealthControllerGetHealth<
  TData = Awaited<ReturnType<typeof healthControllerGetHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthControllerGetHealth>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthControllerGetHealth>>,
          TError,
          Awaited<ReturnType<typeof healthControllerGetHealth>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useHealthControllerGetHealth<
  TData = Awaited<ReturnType<typeof healthControllerGetHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthControllerGetHealth>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Health check endpoint
 */

export function useHealthControllerGetHealth<
  TData = Awaited<ReturnType<typeof healthControllerGetHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthControllerGetHealth>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getHealthControllerGetHealthQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Health check endpoint (POST method)
 */
export const healthControllerPostHealth = (signal?: AbortSignal) => {
  return customInstance<HealthControllerPostHealth200>({
    url: `/api/v1/health`,
    method: "POST",
    signal,
  });
};

export const getHealthControllerPostHealthMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof healthControllerPostHealth>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof healthControllerPostHealth>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["healthControllerPostHealth"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof healthControllerPostHealth>>,
    void
  > = () => {
    return healthControllerPostHealth();
  };

  return { mutationFn, ...mutationOptions };
};

export type HealthControllerPostHealthMutationResult = NonNullable<
  Awaited<ReturnType<typeof healthControllerPostHealth>>
>;

export type HealthControllerPostHealthMutationError = unknown;

/**
 * @summary Health check endpoint (POST method)
 */
export const useHealthControllerPostHealth = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof healthControllerPostHealth>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof healthControllerPostHealth>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getHealthControllerPostHealthMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create API key
 */
export const apiKeysControllerCreate = (
  organizationId: string,
  createApiKeyDto: CreateApiKeyDto,
  signal?: AbortSignal,
) => {
  return customInstance<ApiKeyResponseDto>({
    url: `/api/v1/organizations/${organizationId}/api-keys`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createApiKeyDto,
    signal,
  });
};

export const getApiKeysControllerCreateMutationOptions = <
  TError = null | null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiKeysControllerCreate>>,
    TError,
    { organizationId: string; data: CreateApiKeyDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof apiKeysControllerCreate>>,
  TError,
  { organizationId: string; data: CreateApiKeyDto },
  TContext
> => {
  const mutationKey = ["apiKeysControllerCreate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof apiKeysControllerCreate>>,
    { organizationId: string; data: CreateApiKeyDto }
  > = (props) => {
    const { organizationId, data } = props ?? {};

    return apiKeysControllerCreate(organizationId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApiKeysControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof apiKeysControllerCreate>>
>;
export type ApiKeysControllerCreateMutationBody = CreateApiKeyDto;
export type ApiKeysControllerCreateMutationError = null | null;

/**
 * @summary Create API key
 */
export const useApiKeysControllerCreate = <
  TError = null | null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof apiKeysControllerCreate>>,
      TError,
      { organizationId: string; data: CreateApiKeyDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof apiKeysControllerCreate>>,
  TError,
  { organizationId: string; data: CreateApiKeyDto },
  TContext
> => {
  const mutationOptions = getApiKeysControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get organization API keys
 */
export const apiKeysControllerFindAll = (
  organizationId: string,
  signal?: AbortSignal,
) => {
  return customInstance<ApiKeyResponseDto[]>({
    url: `/api/v1/organizations/${organizationId}/api-keys`,
    method: "GET",
    signal,
  });
};

export const getApiKeysControllerFindAllQueryKey = (
  organizationId?: string,
) => {
  return [`/api/v1/organizations/${organizationId}/api-keys`] as const;
};

export const getApiKeysControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getApiKeysControllerFindAllQueryKey(organizationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof apiKeysControllerFindAll>>
  > = ({ signal }) => apiKeysControllerFindAll(organizationId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ApiKeysControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiKeysControllerFindAll>>
>;
export type ApiKeysControllerFindAllQueryError = unknown;

export function useApiKeysControllerFindAll<
  TData = Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
  TError = unknown,
>(
  organizationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof apiKeysControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useApiKeysControllerFindAll<
  TData = Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof apiKeysControllerFindAll>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useApiKeysControllerFindAll<
  TData = Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get organization API keys
 */

export function useApiKeysControllerFindAll<
  TData = Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
  TError = unknown,
>(
  organizationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindAll>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getApiKeysControllerFindAllQueryOptions(
    organizationId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get API key by ID
 */
export const apiKeysControllerFindOne = (
  organizationId: string,
  id: string,
  signal?: AbortSignal,
) => {
  return customInstance<ApiKeyResponseDto>({
    url: `/api/v1/organizations/${organizationId}/api-keys/${id}`,
    method: "GET",
    signal,
  });
};

export const getApiKeysControllerFindOneQueryKey = (
  organizationId?: string,
  id?: string,
) => {
  return [`/api/v1/organizations/${organizationId}/api-keys/${id}`] as const;
};

export const getApiKeysControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getApiKeysControllerFindOneQueryKey(organizationId, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof apiKeysControllerFindOne>>
  > = ({ signal }) => apiKeysControllerFindOne(organizationId, id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organizationId && id),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type ApiKeysControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiKeysControllerFindOne>>
>;
export type ApiKeysControllerFindOneQueryError = null;

export function useApiKeysControllerFindOne<
  TData = Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof apiKeysControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>;
};
export function useApiKeysControllerFindOne<
  TData = Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof apiKeysControllerFindOne>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useApiKeysControllerFindOne<
  TData = Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get API key by ID
 */

export function useApiKeysControllerFindOne<
  TData = Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
  TError = null,
>(
  organizationId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiKeysControllerFindOne>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getApiKeysControllerFindOneQueryOptions(
    organizationId,
    id,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update API key
 */
export const apiKeysControllerUpdate = (
  organizationId: string,
  id: string,
  updateApiKeyDto: UpdateApiKeyDto,
) => {
  return customInstance<ApiKeyResponseDto>({
    url: `/api/v1/organizations/${organizationId}/api-keys/${id}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: updateApiKeyDto,
  });
};

export const getApiKeysControllerUpdateMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
    TError,
    { organizationId: string; id: string; data: UpdateApiKeyDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
  TError,
  { organizationId: string; id: string; data: UpdateApiKeyDto },
  TContext
> => {
  const mutationKey = ["apiKeysControllerUpdate"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
    { organizationId: string; id: string; data: UpdateApiKeyDto }
  > = (props) => {
    const { organizationId, id, data } = props ?? {};

    return apiKeysControllerUpdate(organizationId, id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApiKeysControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof apiKeysControllerUpdate>>
>;
export type ApiKeysControllerUpdateMutationBody = UpdateApiKeyDto;
export type ApiKeysControllerUpdateMutationError = null;

/**
 * @summary Update API key
 */
export const useApiKeysControllerUpdate = <TError = null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
      TError,
      { organizationId: string; id: string; data: UpdateApiKeyDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
  TError,
  { organizationId: string; id: string; data: UpdateApiKeyDto },
  TContext
> => {
  const mutationOptions = getApiKeysControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete API key
 */
export const apiKeysControllerDelete = (organizationId: string, id: string) => {
  return customInstance<null>({
    url: `/api/v1/organizations/${organizationId}/api-keys/${id}`,
    method: "DELETE",
  });
};

export const getApiKeysControllerDeleteMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiKeysControllerDelete>>,
    TError,
    { organizationId: string; id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof apiKeysControllerDelete>>,
  TError,
  { organizationId: string; id: string },
  TContext
> => {
  const mutationKey = ["apiKeysControllerDelete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof apiKeysControllerDelete>>,
    { organizationId: string; id: string }
  > = (props) => {
    const { organizationId, id } = props ?? {};

    return apiKeysControllerDelete(organizationId, id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApiKeysControllerDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof apiKeysControllerDelete>>
>;

export type ApiKeysControllerDeleteMutationError = null;

/**
 * @summary Delete API key
 */
export const useApiKeysControllerDelete = <TError = null, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof apiKeysControllerDelete>>,
      TError,
      { organizationId: string; id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof apiKeysControllerDelete>>,
  TError,
  { organizationId: string; id: string },
  TContext
> => {
  const mutationOptions = getApiKeysControllerDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Toggle API key active status
 */
export const apiKeysControllerToggleActive = (
  organizationId: string,
  id: string,
) => {
  return customInstance<ApiKeyResponseDto>({
    url: `/api/v1/organizations/${organizationId}/api-keys/${id}/toggle`,
    method: "PATCH",
  });
};

export const getApiKeysControllerToggleActiveMutationOptions = <
  TError = null,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiKeysControllerToggleActive>>,
    TError,
    { organizationId: string; id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof apiKeysControllerToggleActive>>,
  TError,
  { organizationId: string; id: string },
  TContext
> => {
  const mutationKey = ["apiKeysControllerToggleActive"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof apiKeysControllerToggleActive>>,
    { organizationId: string; id: string }
  > = (props) => {
    const { organizationId, id } = props ?? {};

    return apiKeysControllerToggleActive(organizationId, id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApiKeysControllerToggleActiveMutationResult = NonNullable<
  Awaited<ReturnType<typeof apiKeysControllerToggleActive>>
>;

export type ApiKeysControllerToggleActiveMutationError = null;

/**
 * @summary Toggle API key active status
 */
export const useApiKeysControllerToggleActive = <
  TError = null,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof apiKeysControllerToggleActive>>,
      TError,
      { organizationId: string; id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof apiKeysControllerToggleActive>>,
  TError,
  { organizationId: string; id: string },
  TContext
> => {
  const mutationOptions =
    getApiKeysControllerToggleActiveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
